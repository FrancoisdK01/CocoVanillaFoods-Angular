import { Injectable } from '@angular/core';
import pdfMake from 'pdfmake/build/pdfmake';
import pdfFonts from 'pdfmake/build/vfs_fonts';
import { Inventory } from 'src/app/Model/inventory';
import { DataServiceService } from 'src/app/customer/services/data-service.service';
import { Event } from 'src/app/Model/event';
import { Blacklist } from 'src/app/Model/blacklist';
import { Wine } from 'src/app/Model/wine';
import { WineType } from 'src/app/Model/winetype';
import { Varietal } from 'src/app/Model/varietal';
import { ToastrService } from 'ngx-toastr';
import { WineService } from '../services/wine.service';
import { WinetypeService } from './winetype.service';
import { VarietalService } from './varietal.service';
import { SupplierService } from './supplier.service';
import { SuppOrderAndVATViewModel } from 'src/app/Model/SupplierOrdersVATs';
import { VAT } from 'src/app/Model/vat';
import { InventoryService } from './inventory.service';

pdfMake.vfs = pdfFonts.pdfMake.vfs;

@Injectable({
  providedIn: 'root',
})
export class PdfService {
  user: any;
  blacklistData: any;

  constructor(
    private userService: DataServiceService,
    private wineService: WineService,
    private winetypeService: WinetypeService,
    private varietalService: VarietalService,
    private supplierService: SupplierService,
    private inventoryService: InventoryService,
    private toastr: ToastrService
  ) {
    var tokenUser = this.userService.getUserFromToken();
    this.userService.getUser(tokenUser!.email).subscribe((result: any) => {
      this.user = result.user;
    });
  }
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  //Inventory Report
  wines: Wine[] = [];
  allWines: Wine[] = [];
  winetypes: WineType[] = [];
  varietals: Varietal[] = [];
  searchQuery: string = '';
  headerString: string = '';

  getWineName(wineID: number): string {
    console.log('Name ID', wineID);
    let wine = this.allWines.find((x) => x.wineID == wineID);
    console.log('Wine', wine);
    return wine ? wine.name : 'Unknown';
  }

  getVarietalName(varietalID: number): string {
    console.log('V ID', varietalID);
    let varietal = this.varietals.find((x) => x.varietalID == varietalID);
    return varietal?.name || 'Unknown';
  }

  getWinetypeName(wineTypeID?: number): string {
    console.log('Type ID', wineTypeID);
    let winetype = this.winetypes.find((x) => x.wineTypeID == wineTypeID);
    return winetype?.name || 'Unknown';
  }

  getWineVintage(wineID: number): string {
    let wine = this.allWines.find(w => w.wineID === wineID);
    return wine?.vintage || 'Unknown';
  }

  async loadWines(): Promise<void> {
    try {
      this.allWines = await this.wineService.getWines();
      console.log('All Wines:', this.allWines);
      this.winetypes = await this.winetypeService.getWinetypes();
      this.varietals = await this.varietalService.getVarietals();
      this.filterWines();
    } catch (error) {
      console.error(error);
      this.toastr.error('Error, please try again', 'Wine Table');
    }
  }

  filterWines(): void {
    if (this.searchQuery.trim() !== '') {
      const query = this.searchQuery.toLowerCase().trim();
      this.wines = this.allWines.filter(
        (wine) =>
          wine.name.toLowerCase().includes(query) ||
          wine.vintage.toString().includes(query) ||
          wine.varietalID.toString().includes(query) ||
          wine.wineTypeID.toString().includes(query) ||
          wine.price.toString().includes(query)
      );
    } else {
      this.wines = [...this.allWines]; // if searchQuery is empty, show all wines
    }
  }

  async generateInventoryPdf(
    inventoryData: Inventory[],
    currentDate: string
  ): Promise<Blob> {
    type Alignment = 'left' | 'right' | 'center' | 'justify';
    this.headerString = await this.toBase64('assets/download.png');
    this.loadWines();

    const delay = (ms: number) =>
      new Promise((resolve) => setTimeout(resolve, ms));

    if (currentDate == null) {
      this.toastr.warning('Please input begin and end date', 'Error');
    } else {
      this.toastr.success('Generating...', 'Report');
    }

    await delay(1234);
    // if(this.getWineName(inventoryData.wineID) == 'Unknown'){

    // }

    return new Promise<Blob>((resolve, reject) => {
      let documentDefinition: any;

      if (inventoryData.length > 0) {
        console.log(inventoryData);
        documentDefinition = {
          header: {
            image: this.headerString,
            fit: [40, 40] as [number, number],
            alignment: 'center' as Alignment,
          },
          content: [
            { text: 'Inventory Report', style: 'header' },
            {
              text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`,
              style: 'subheader',
            },
            { text: `Date generated: ${currentDate}`, style: 'subheader' },
            '\n',
            {
              table: {
                headerRows: 1,
                widths: ['auto', '*', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto'],
                body: [
                  [
                    'No.',
                    'Wine Name',
                    'Wine Varietal',
                    'Wine Type',
                    'Wine Price',
                    'Vintage',
                    'Stock Limit',
                    'Quantity on Hand',
                  ],
                  ...inventoryData.map((item, index) => [
                    index + 1,
                    {
                      text: this.getWineName(item.wineID) || 'N/A',
                      noWrap: false,
                    },
                    {
                      text: this.getVarietalName(item.varietalID) || 'N/A',
                      noWrap: false,
                    },
                    {
                      text: this.getWinetypeName(item.wineTypeID) || 'N/A',
                      noWrap: false,
                    },{
                      text: this.getWineVintage(item.wineTypeID) || 'N/A',
                      noWrap: false,
                    },
                    { text: 'R ' + item.winePrice || 'N/A', noWrap: false },
                    { text: item.stockLimit || 'N/A', noWrap: false },
                    { text: item.quantityOnHand || 'N/A', noWrap: false },
                  ]),
                ],
              },
            },
          ],
          footer: function (currentPage: number, pageCount: number): any {
            return {
              columns: [
                'VITITECH',
                {
                  text: 'Page ' + currentPage.toString() + ' of ' + pageCount,
                  alignment: 'right' as Alignment,
                },
              ],
              margin: [30, 0] as [number, number],
            };
          },
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10],
            },
            subheader: {
              fontSize: 12,
              italics: true,
              margin: [0, 5, 0, 5],
            },
          },
        };
      } else {
        documentDefinition = {
          header: {
            image: this.headerString,
            fit: [40, 40] as [number, number],
            alignment: 'center' as Alignment,
          },
          content: [
            { text: 'Inventory Report', style: 'header' },
            {
              text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`,
              style: 'subheader',
            },
            { text: `Date: ${currentDate}`, style: 'subheader' },
            '\n',
            {
              table: {
                headerRows: 1,
                widths: ['auto'],
                body: [['There is nothing stored in Inventory at the moment.']],
              },
            },
            '\n',
            { text: '*********** Report End ***********', style: 'reportEnd' },
          ],
          footer: function (currentPage: number, pageCount: number): any {
            return {
              columns: [
                'VITITECH',
                {
                  text: 'Page ' + currentPage.toString() + ' of ' + pageCount,
                  alignment: 'right' as Alignment,
                },
              ],
              margin: [30, 0] as [number, number],
            };
          },
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10],
            },
            subheader: {
              fontSize: 12,
              italics: true,
              margin: [0, 5, 0, 5],
            },
            reportEnd: {
              fontSize: 14,
              bold: true,
              margin: [0, 7, 0, 7],
              alignment: 'center',
            },
          },
        };
      }

      pdfMake
        .createPdf(documentDefinition)
        .download(`inventory_report_${currentDate}.pdf`);
    });
  }

  async generateInventoryReport(
    inventoryData: Inventory[],
    currentDate: string
  ): Promise<Blob> {
    type Alignment = 'left' | 'right' | 'center' | 'justify';
    this.headerString = await this.toBase64('assets/download.png');
    this.loadWines();
    const delay = (ms: number) =>
      new Promise((resolve) => setTimeout(resolve, ms));

    if (currentDate == null) {
      this.toastr.warning('Please input begin and end date', 'Error');
    } else {
      this.toastr.success('Generating...', 'Report');
    }

    await delay(1234);
    return new Promise<Blob>((resolve, reject) => {
      let documentDefinition: any;

      if (inventoryData.length > 0) {
        console.log(inventoryData);
        documentDefinition = {
          header: {
            image: this.headerString,
            fit: [40, 40] as [number, number],
            alignment: 'center' as Alignment,
          },
          content: [
            { text: 'Inventory Report', style: 'header' },
            {
              text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`,
              style: 'subheader',
            },
            { text: `Date generated: ${currentDate}`, style: 'subheader' },
            '\n',
            {
              table: {
                headerRows: 1,
                widths: ['auto', '*', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto'],
                body: [
                  [
                    'No.',
                    'Wine Name',
                    'Wine Varietal',
                    'Wine Type',
                    'Wine Price',
                    'Wine Vintage',
                    'Stock Limit',
                    'Quantity on Hand',
                  ],
                  ...inventoryData.map((item, index) => [
                    index + 1,
                    {
                      text: this.getWineName(item.wineID) || 'N/A',
                      noWrap: true,
                    },
                    {
                      text: this.getVarietalName(item.varietalID) || 'N/A',
                      noWrap: false,
                    },
                    {
                      text: this.getWinetypeName(item.wineTypeID) || 'N/A',
                      noWrap: true,
                    },
                    { text: 'R ' + item.winePrice || 'N/A', noWrap: false },
                    { text: this.getWineVintage(item.wineID), noWrap: true},
                    { text: item.stockLimit || 'N/A', noWrap: false },
                    { text: item.quantityOnHand || 'N/A', noWrap: false },
                  ]),
                ],
              },
            },
            '\n',
            { text: '*********** Report End ***********', style: 'reportEnd' },
          ],
          footer: function (currentPage: number, pageCount: number): any {
            return {
              columns: [
                'VITITECH',
                {
                  text: 'Page ' + currentPage.toString() + ' of ' + pageCount,
                  alignment: 'right' as Alignment,
                },
              ],
              margin: [30, 0] as [number, number],
            };
          },
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10],
            },
            subheader: {
              fontSize: 12,
              italics: true,
              margin: [0, 5, 0, 5],
            },
            reportEnd: {
              fontSize: 14,
              bold: true,
              margin: [0, 7, 0, 7],
              alignment: 'center',
            },
          },
        };
      } else {
        documentDefinition = {
          header: {
            image: this.headerString,
            fit: [40, 40] as [number, number],
            alignment: 'center' as Alignment,
          },
          content: [
            { text: 'Inventory Report', style: 'header' },
            {
              table: {
                headerRows: 1,
                widths: ['auto'],
                body: [['No inventory items found.']],
              },
            },
          ],
          footer: function (currentPage: number, pageCount: number): any {
            return {
              columns: [
                'VITITECH',
                {
                  text: 'Page ' + currentPage.toString() + ' of ' + pageCount,
                  alignment: 'right' as Alignment,
                },
              ],
              margin: [30, 0] as [number, number],
            };
          },
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10],
            },
          },
        };
      }

      const pdfDocGenerator = pdfMake.createPdf(documentDefinition);

      pdfDocGenerator.getBlob((pdfBlob: Blob) => {
        resolve(pdfBlob);
      });
    });
  }

  //---------------------------------------------------  Events  ----------------------------------------------------------------

  async generateEventsPdf(
    eventData: Event[],
    beginDate: Date,
    endDate: Date
  ): Promise<void> {
    type Alignment = 'left' | 'right' | 'center' | 'justify';
    this.headerString = await this.toBase64('assets/download.png');
    let formattedBeginDate = new Date(beginDate).toLocaleDateString();
    let formattedEndDate = new Date(endDate).toLocaleDateString();
    let generatedDate = Date.now();

    let documentDefinition: any;

    if (beginDate == null || endDate == null) {
      this.toastr.warning('Please input begin and end date', 'Error');
    } else {
      this.toastr.success('Generating...', 'Report');
    }

    if (eventData.length > 0) {
      documentDefinition = {
        header: {
          image: this.headerString,
          fit: [40, 40] as [number, number],
          alignment: 'center' as Alignment,
        },
        content: [
          { text: 'Events Report', style: 'header' },
          {
            text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`,
            style: 'subheader',
          },
          {
            text: `Generated On: ${new Date(
              generatedDate
            ).toLocaleDateString()}`,
            style: 'subheader',
          },
          {
            text: `Time Period: ${formattedBeginDate} -- ${formattedEndDate}`,
            style: 'subheader',
          },
          '\n',
          {
            table: {
              headerRows: 1,
              widths: [
                'auto',
                '*',
                'auto',
                'auto',
                'auto',
                'auto',
                'auto',
                'auto',
                'auto',
              ],
              body: [
                [
                  'No.',
                  'Name',
                  'Date',
                  'Tickets Available',
                  'Tickets Sold',
                  'Price',
                  'Early Bird Discount',
                  'Revenue',
                  'Active',
                ],
                ...eventData.map((event, index) => {
                  const eventEarlyBirdlimit = event.earlyBird?.limit || 0; // Default to 0 if null
                  const eventEarlyBirdPercentage =
                    event.earlyBird?.percentage || 0; // Default to 0 if null
                  const eventActive = event.displayItem ? 'Yes' : 'No';

                  const earlyBirdPrice =
                    event.price -
                    (event.price * eventEarlyBirdPercentage) / 100;
                  const earlyBirdDiscountAmount = event.price - earlyBirdPrice; // Calculating discount amount

                  const earlyBirdTicketsSold =
                    event.tickets_Sold <= eventEarlyBirdlimit
                      ? event.tickets_Sold
                      : eventEarlyBirdlimit;
                  const regularTicketsSold =
                    event.tickets_Sold - earlyBirdTicketsSold;

                  const revenueFromEarlyBirdTickets =
                    earlyBirdTicketsSold * earlyBirdPrice;
                  const revenueFromRegularTickets =
                    regularTicketsSold * event.price;
                  const totalRevenue =
                    revenueFromEarlyBirdTickets + revenueFromRegularTickets;

                  return [
                    index + 1,
                    { text: event.name, noWrap: false },
                    {
                      text: new Date(event.eventDate).toLocaleDateString(),
                      noWrap: false,
                    },
                    { text: event.tickets_Available, noWrap: false },
                    { text: event.tickets_Sold, noWrap: false },
                    { text: `R${event.price}`, noWrap: false },
                    {
                      text: `R${earlyBirdDiscountAmount.toFixed(2)}`,
                      noWrap: false,
                    }, // Added "Early Bird Discount" column value and fixed it to two decimal places
                    { text: `R${totalRevenue.toFixed(2)}`, noWrap: false }, // Fixing to two decimal places for cleaner display
                    { text: eventActive, noWrap: false },
                  ];
                }),
              ],
            },
          },
          '\n',
          { text: '*********** Report End ***********', style: 'reportEnd' },
        ],
        footer: function (currentPage: number, pageCount: number): any {
          return {
            columns: [
              'VITITECH',
              {
                text: 'Page ' + currentPage.toString() + ' of ' + pageCount,
                alignment: 'right' as Alignment,
              },
            ],
            margin: [30, 0] as [number, number],
          };
        },
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10],
          },
          subheader: {
            fontSize: 12,
            italics: true,
            margin: [0, 5, 0, 5],
          },
          reportEnd: {
            fontSize: 14,
            bold: true,
            margin: [0, 7, 0, 7],
            alignment: 'center',
          },
        },
      };
    } else {
      documentDefinition = {
        header: {
          image: this.headerString,
          fit: [40, 40] as [number, number],
          alignment: 'center' as Alignment,
        },
        content: [
          { text: 'Events Report', style: 'header' },
          {
            text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`,
            style: 'subheader',
          },
          {
            text: `From: ${formattedBeginDate} To: ${formattedEndDate}`,
            style: 'subheader',
          },
          '\n',
          {
            table: {
              headerRows: 1,
              widths: ['auto'],
              body: [['There are no events between the specified dates.']],
            },
          },
        ],
        footer: function (currentPage: number, pageCount: number): any {
          return {
            columns: [
              'VITITECH',
              {
                text: 'Page ' + currentPage.toString() + ' of ' + pageCount,
                alignment: 'right' as Alignment,
              },
            ],
            margin: [30, 0] as [number, number],
          };
        },
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10],
          },
          subheader: {
            fontSize: 12,
            italics: true,
            margin: [0, 5, 0, 5],
          },
        },
      };
    }

    pdfMake
      .createPdf(documentDefinition)
      .download(`events_report_${formattedBeginDate}_${formattedEndDate}.pdf`);
  }

  async generateEventsReport(
    eventData: Event[],
    beginDate: Date,
    endDate: Date,
    currentDate: string
  ): Promise<Blob> {
    type Alignment = 'left' | 'right' | 'center' | 'justify';
    this.headerString = await this.toBase64('assets/download.png');
    if (beginDate == null || endDate == null) {
      this.toastr.warning('Please input begin and end date', 'Error');
    } else {
      this.toastr.success('Generating...', 'Report');
    }

    return new Promise<Blob>((resolve, reject) => {
      let documentDefinition: any;
      let formattedBeginDate = new Date(beginDate).toLocaleDateString();
      let formattedEndDate = new Date(endDate).toLocaleDateString();
      let generatedDate = Date.now();

      if (eventData.length > 0) {
        documentDefinition = {
          header: {
            image: this.headerString,
            fit: [40, 40] as [number, number],
            alignment: 'center' as Alignment,
          },
          content: [
            { text: 'Events Report', style: 'header' },
            {
              text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`,
              style: 'subheader',
            },
            {
              text: `Generated On: ${new Date(
                generatedDate
              ).toLocaleDateString()}`,
              style: 'subheader',
            },
            {
              text: `Time Period: ${formattedBeginDate} -- ${formattedEndDate}`,
              style: 'subheader',
            },
            '\n',
            {
              table: {
                headerRows: 1,
                widths: [
                  'auto',
                  '*',
                  'auto',
                  'auto',
                  'auto',
                  'auto',
                  'auto',
                  'auto',
                  'auto',
                ],
                body: [
                  [
                    'No.',
                    'Name',
                    'Date',
                    'Tickets Available',
                    'Tickets Sold',
                    'Price',
                    'Early Bird Discount',
                    'Revenue',
                    'Active',
                  ],
                  ...eventData.map((event, index) => {
                    const eventEarlyBirdlimit = event.earlyBird?.limit || 0; // Default to 0 if null
                    const eventEarlyBirdPercentage =
                      event.earlyBird?.percentage || 0; // Default to 0 if null
                    const eventActive = event.displayItem ? 'Yes' : 'No';

                    const earlyBirdPrice =
                      event.price -
                      (event.price * eventEarlyBirdPercentage) / 100;
                    const earlyBirdDiscountAmount =
                      event.price - earlyBirdPrice; // Calculating discount amount

                    const earlyBirdTicketsSold =
                      event.tickets_Sold <= eventEarlyBirdlimit
                        ? event.tickets_Sold
                        : eventEarlyBirdlimit;
                    const regularTicketsSold =
                      event.tickets_Sold - earlyBirdTicketsSold;

                    const revenueFromEarlyBirdTickets =
                      earlyBirdTicketsSold * earlyBirdPrice;
                    const revenueFromRegularTickets =
                      regularTicketsSold * event.price;
                    const totalRevenue =
                      revenueFromEarlyBirdTickets + revenueFromRegularTickets;

                    return [
                      index + 1,
                      { text: event.name, noWrap: false },
                      {
                        text: new Date(event.eventDate).toLocaleDateString(),
                        noWrap: false,
                      },
                      { text: event.tickets_Available, noWrap: false },
                      { text: event.tickets_Sold, noWrap: false },
                      { text: `R${event.price}`, noWrap: false },
                      {
                        text: `R${earlyBirdDiscountAmount.toFixed(2)}`,
                        noWrap: false,
                      }, // Added "Early Bird Discount" column value and fixed it to two decimal places
                      { text: `R${totalRevenue.toFixed(2)}`, noWrap: false }, // Fixing to two decimal places for cleaner display
                      { text: eventActive, noWrap: false },
                    ];
                  }),
                ],
              },
            },
            '\n',
            { text: '*********** Report End ***********', style: 'reportEnd' },
          ],
          footer: function (currentPage: number, pageCount: number): any {
            return {
              columns: [
                'VITITECH',
                {
                  text: 'Page ' + currentPage.toString() + ' of ' + pageCount,
                  alignment: 'right' as Alignment,
                },
              ],
              margin: [30, 0] as [number, number],
            };
          },
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10],
            },
            subheader: {
              fontSize: 12,
              italics: true,
              margin: [0, 5, 0, 5],
            },
            reportEnd: {
              fontSize: 14,
              bold: true,
              margin: [0, 7, 0, 7],
              alignment: 'center',
            },
          },
        };
      } else {
        documentDefinition = {
          content: [
            { text: 'Events Report', style: 'header' },
            {
              table: {
                headerRows: 1,
                widths: ['auto'],
                body: [['No events available.']],
              },
            },
          ],
          footer: function (currentPage: number, pageCount: number): any {
            return {
              columns: [
                'VITITECH',
                {
                  text: 'Page ' + currentPage.toString() + ' of ' + pageCount,
                  alignment: 'right' as Alignment,
                },
              ],
              margin: [30, 0] as [number, number],
            };
          },
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10],
            },
          },
        };
      }

      const pdfDocGenerator = pdfMake.createPdf(documentDefinition);

      pdfDocGenerator.getBlob((pdfBlob: Blob) => {
        resolve(pdfBlob);
      });
    });
  }

  //---------------------------------------------------  Events  ----------------------------------------------------------------

  //---------------------------------------------------  Supplier Order  ----------------------------------------------------------------

  async generateSupplierOrdersPdf(
    supplierOrderData: SuppOrderAndVATViewModel[]
  ): Promise<Blob> {
    type Alignment = 'left' | 'right' | 'center' | 'justify';
    return new Promise<Blob>((resolve, reject) => {
      console.log('SupplierOrder And VAT:', supplierOrderData);
      let generatedDate = Date.now();
      let supplierTotals: { [key: string]: number } = {};
      this.toastr.success('Generating...', 'Report');

      // Extract VAT percentage
      if (!supplierOrderData[0].vaTs?.percentage) {
        if (!supplierOrderData[0].vaTs) {
          supplierOrderData[0].vaTs = {
            vatid: 0,
            percentage: 15,
            date: new Date(), // Assuming the date format you want is a Date object
          };
        }
      }
      const delay = (ms: number) =>
      new Promise((resolve) => setTimeout(resolve, ms));
      this.loadWines().then(() => {
        delay(1234);
      });
      
      const vatPercentage = supplierOrderData[0].vaTs.percentage ?? 0.15; // Convert to a proportion for calculation

      let body: any[] = [
        [
          'Order Ref',
          'Supplier',
          'Wine',
          'Quantity Ordered',
          'Cost(excl VAT)',
          `VAT (${supplierOrderData[0].vaTs.percentage}%)`,
          'Sub-Total',
        ],
      ];
      let supplierTotalBody: any[] = [['Supplier Name', 'Total Amount Paid']];

      let grandTotal = 0;
      const flattenedSupplierOrders = supplierOrderData
        .flatMap((data) => data.supplierOrders || [])
        .filter((order) => !!order);

      Promise.all(
        flattenedSupplierOrders.map((order) => {
          return new Promise<string>((resolve, reject) => {
            this.supplierService.getSupplier(order.supplierID!).subscribe(
              (result: any) => resolve(result.name),
              (error) => reject(error)
            );
          });
        })
      ).then(async (supplierNames) => {
        flattenedSupplierOrders.forEach(async (order, index) => {
          let orderValueText, vatText, totalWithVatText;
          if (order.isBackOrder) {
            orderValueText = vatText = totalWithVatText = "BO*";
          } else {
            const vat = ((order.orderTotal ?? 0) * vatPercentage) / 100;
            const totalWithVat = order.orderTotal ?? 0;
            const orderValue = (order.orderTotal || 0) * (1 - vatPercentage / 100);
            grandTotal += totalWithVat;
        
            orderValueText = `R ${orderValue.toFixed(2)}`;
            vatText = `R ${vat.toFixed(2)}`;
            totalWithVatText = `R ${totalWithVat.toFixed(2)}`;
          }
        
          const quantityOrdered = order.quantity_Ordered ?? 0;
          let inventoryWineID = (await this.inventoryService.getItemInventory(order.inventoryID!)).wineID
          body.push([
            { text: order.supplierOrderRefNum, noWrap: false },
            { text: supplierNames[index], noWrap: false },
            { text: `${this.getWineName(inventoryWineID)} (${this.getWineVintage(inventoryWineID)})`, noWrap: true },
            { text: quantityOrdered, noWrap: false },
            { text: orderValueText, noWrap: true },
            { text: vatText, noWrap: false },
            { text: totalWithVatText, noWrap: false },
          ]);
        });
        

        let addedSuppliers = new Set<string>();
        this.headerString = await this.toBase64('assets/download.png');

        flattenedSupplierOrders.forEach((order) => {
          const vat = ((order.orderTotal ?? 0) * vatPercentage) / 100;
          const orderValue = order.orderTotal!;

          if (order.supplierID !== undefined) {
            if (!supplierTotals[order.supplierID]) {
              supplierTotals[order.supplierID] = 0; // Initialize if not already set
            }
            supplierTotals[order.supplierID] += orderValue; // Add to the supplier's total
          }
        });

        flattenedSupplierOrders.forEach((order, index) => {
          if (order.supplierID !== undefined) {
            const supplierIDStr = String(order.supplierID);
            if (!addedSuppliers.has(supplierIDStr)) {
              supplierTotalBody.push([
                supplierNames[index],
                `R ${supplierTotals[order.supplierID].toFixed(2)}`,
              ]);
              addedSuppliers.add(supplierIDStr);
            }
          }
        });

        // After you've added all suppliers and their totals, add the grand total:
        supplierTotalBody.push(['', `R ${grandTotal.toFixed(2)}`]);
        await delay(1234);
        body.push([
          {},
          {},
          {},
          {},
          {},
          { text: 'Grand Total:', bold: true },
          { text: `R ${grandTotal.toFixed(2)}`, bold: true },
        ]);
        
        const documentDefinition = {
          header: {
            image: this.headerString,
            fit: [40, 40] as [number, number],
            alignment: 'center' as Alignment,
          },
          content: [
            { text: 'Supplier Order Report', style: 'header' },
            {
              text: `Generated by: ${this.user.first_Name} ${this.user.last_Name}`,
              style: 'subheader',
            },
            {
              text: `Generated On: ${new Date(
                generatedDate
              ).toLocaleDateString()}`,
              style: 'subheader',
            },
            '\n',
            {
              table: {
                headerRows: 1,
                widths: [
                  'auto',
                  'auto',
                  'auto',
                  'auto',
                  'auto',
                  'auto',
                  'auto',
                ],
                body: body,
              },
              layout: {
                fillColor: function (
                  rowIndex: number,
                  node: any,
                  columnIndex: number
                ) {
                  return rowIndex === body.length - 1 ? '#DDDDDD' : null; // grey background for the last row
                },
              },
            },
            { text: '* - Back Order', style: "superscript" },
            '\n',
            '\n', // Space between tables
            {
              table: {
                widths: ['70%', '30%'],
                body: supplierTotalBody,
              },
              layout: {
                fillColor: function (
                  rowIndex: number,
                  node: any,
                  columnIndex: number
                ) {
                  return rowIndex === supplierTotalBody.length - 1
                    ? '#DDDDDD'
                    : null; // grey background for the last row
                },
              },
            },
            '\n',
            { text: '*********** Report End ***********', style: 'reportEnd' },
          ],
          footer: function (currentPage: number, pageCount: number): any {
            return {
              columns: [
                'VITITECH',
                {
                  text: 'Page ' + currentPage.toString() + ' of ' + pageCount,
                  alignment: 'right' as Alignment,
                },
              ],
              margin: [30, 0] as [number, number],
            };
          },
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10] as [number, number, number, number],
            },
            subheader: {
              fontSize: 12,
              italics: true,
              margin: [0, 5, 0, 5] as [number, number, number, number],
            },
            reportEnd: {
              fontSize: 14,
              bold: true,
              margin: [0, 7, 0, 7] as [number, number, number, number],
              alignment: 'center' as Alignment,
            },
            superscript: {
              fontsize: 8,
              margin: [0, 2, 0, 2] as [number, number, number, number]
            }
          },
          pageOrientation: 'portrait' as const,
        };
      pdfMake
        .createPdf(documentDefinition)
        .download(`supplier_order_report_${generatedDate}.pdf`);
    });
  });
  }

  async generateSupplierOrders(
    supplierOrderData: SuppOrderAndVATViewModel[]
  ): Promise<Blob> {
    type Alignment = 'left' | 'right' | 'center' | 'justify';
    return new Promise<Blob>((resolve, reject) => {
      console.log('SupplierOrder And VAT:', supplierOrderData);
      let generatedDate = Date.now();
      let supplierTotals: { [key: string]: number } = {};
      this.toastr.success('Generating...', 'Report');

      // Extract VAT percentage
      if (!supplierOrderData[0].vaTs?.percentage) {
        if (!supplierOrderData[0].vaTs) {
          supplierOrderData[0].vaTs = {
            vatid: 0,
            percentage: 15,
            date: new Date(), // Assuming the date format you want is a Date object
          };
        }
      }
      const delay = (ms: number) =>
      new Promise((resolve) => setTimeout(resolve, ms));
      this.loadWines().then(() => {
        delay(1234);
      });
      
      const vatPercentage = supplierOrderData[0].vaTs.percentage ?? 0.15; // Convert to a proportion for calculation

      let body: any[] = [
        [
          'Order Ref',
          'Supplier',
          'Wine',
          'Quantity Ordered',
          'Cost(excl VAT)',
          `VAT (${supplierOrderData[0].vaTs.percentage}%)`,
          'Sub-Total',
        ],
      ];
      let supplierTotalBody: any[] = [['Supplier Name', 'Total Amount Paid']];

      let grandTotal = 0;
      const flattenedSupplierOrders = supplierOrderData
        .flatMap((data) => data.supplierOrders || [])
        .filter((order) => !!order);

      Promise.all(
        flattenedSupplierOrders.map((order) => {
          return new Promise<string>((resolve, reject) => {
            this.supplierService.getSupplier(order.supplierID!).subscribe(
              (result: any) => resolve(result.name),
              (error) => reject(error)
            );
          });
        })
      ).then(async (supplierNames) => {
        flattenedSupplierOrders.forEach(async (order, index) => {
          let orderValueText, vatText, totalWithVatText;
          if (order.isBackOrder) {
            orderValueText = vatText = totalWithVatText = "BO*";
          } else {
            const vat = ((order.orderTotal ?? 0) * vatPercentage) / 100;
            const totalWithVat = order.orderTotal ?? 0;
            const orderValue = (order.orderTotal || 0) * (1 - vatPercentage / 100);
            grandTotal += totalWithVat;
        
            orderValueText = `R ${orderValue.toFixed(2)}`;
            vatText = `R ${vat.toFixed(2)}`;
            totalWithVatText = `R ${totalWithVat.toFixed(2)}`;
          }
        
          const quantityOrdered = order.quantity_Ordered ?? 0;
          let inventoryWineID = (await this.inventoryService.getItemInventory(order.inventoryID!)).wineID
          body.push([
            { text: order.supplierOrderRefNum, noWrap: false },
            { text: supplierNames[index], noWrap: false },
            { text: `${this.getWineName(inventoryWineID)} (${this.getWineVintage(inventoryWineID)})`, noWrap: true },
            { text: quantityOrdered, noWrap: false },
            { text: orderValueText, noWrap: true },
            { text: vatText, noWrap: false },
            { text: totalWithVatText, noWrap: false },
          ]);
        });
        

        let addedSuppliers = new Set<string>();
        this.headerString = await this.toBase64('assets/download.png');

        flattenedSupplierOrders.forEach((order) => {
          const vat = ((order.orderTotal ?? 0) * vatPercentage) / 100;
          const orderValue = order.orderTotal!;

          if (order.supplierID !== undefined) {
            if (!supplierTotals[order.supplierID]) {
              supplierTotals[order.supplierID] = 0; // Initialize if not already set
            }
            supplierTotals[order.supplierID] += orderValue; // Add to the supplier's total
          }
        });

        flattenedSupplierOrders.forEach((order, index) => {
          if (order.supplierID !== undefined) {
            const supplierIDStr = String(order.supplierID);
            if (!addedSuppliers.has(supplierIDStr)) {
              supplierTotalBody.push([
                supplierNames[index],
                `R ${supplierTotals[order.supplierID].toFixed(2)}`,
              ]);
              addedSuppliers.add(supplierIDStr);
            }
          }
        });

        // After you've added all suppliers and their totals, add the grand total:
        supplierTotalBody.push(['', `R ${grandTotal.toFixed(2)}`]);
        await delay(1234);
        body.push([
          {},
          {},
          {},
          {},
          {},
          { text: 'Grand Total:', bold: true },
          { text: `R ${grandTotal.toFixed(2)}`, bold: true },
        ]);
        
        const documentDefinition = {
          header: {
            image: this.headerString,
            fit: [40, 40] as [number, number],
            alignment: 'center' as Alignment,
          },
          content: [
            { text: 'Supplier Order Report', style: 'header' },
            {
              text: `Generated by: ${this.user.first_Name} ${this.user.last_Name}`,
              style: 'subheader',
            },
            {
              text: `Generated On: ${new Date(
                generatedDate
              ).toLocaleDateString()}`,
              style: 'subheader',
            },
            '\n',
            {
              table: {
                headerRows: 1,
                widths: [
                  'auto',
                  'auto',
                  'auto',
                  'auto',
                  'auto',
                  'auto',
                  'auto',
                ],
                body: body,
              },
              layout: {
                fillColor: function (
                  rowIndex: number,
                  node: any,
                  columnIndex: number
                ) {
                  return rowIndex === body.length - 1 ? '#DDDDDD' : null; // grey background for the last row
                },
              },
            },
            { text: '* - Back Order', style: "superscript" },
            '\n',
            '\n', // Space between tables
            {
              table: {
                widths: ['70%', '30%'],
                body: supplierTotalBody,
              },
              layout: {
                fillColor: function (
                  rowIndex: number,
                  node: any,
                  columnIndex: number
                ) {
                  return rowIndex === supplierTotalBody.length - 1
                    ? '#DDDDDD'
                    : null; // grey background for the last row
                },
              },
            },
            '\n',
            { text: '*********** Report End ***********', style: 'reportEnd' },
          ],
          footer: function (currentPage: number, pageCount: number): any {
            return {
              columns: [
                'VITITECH',
                {
                  text: 'Page ' + currentPage.toString() + ' of ' + pageCount,
                  alignment: 'right' as Alignment,
                },
              ],
              margin: [30, 0] as [number, number],
            };
          },
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10] as [number, number, number, number],
            },
            subheader: {
              fontSize: 12,
              italics: true,
              margin: [0, 5, 0, 5] as [number, number, number, number],
            },
            reportEnd: {
              fontSize: 14,
              bold: true,
              margin: [0, 7, 0, 7] as [number, number, number, number],
              alignment: 'center' as Alignment,
            },
            superscript: {
              fontsize: 8,
              margin: [0, 2, 0, 2] as [number, number, number, number]
            }
          },
          pageOrientation: 'portrait' as const,
        };

        const pdfDocGenerator = pdfMake.createPdf(documentDefinition);

        pdfDocGenerator.getBlob((pdfBlob: Blob) => {
          resolve(pdfBlob);
        });
      });
    });
  }

  //---------------------------------------------------  Supplier Order  ----------------------------------------------------------------

  //---------------------------------------------------  Blacklist  ----------------------------------------------------------------

  async generateBlacklistPdf(
    blacklistData: Blacklist[],
    currentDate: string
  ): Promise<void> {
    type Alignment = 'left' | 'right' | 'center' | 'justify';
    let documentDefinition: any;
    this.headerString = await this.toBase64('assets/download.png');
    this.toastr.success('Generating...', 'Report');

    if (blacklistData.length > 0) {
      documentDefinition = {
        header: {
          image: this.headerString,
          fit: [40, 40] as [number, number],
          alignment: 'center' as Alignment,
        },
        content: [
          { text: 'Blacklist Report', style: 'header' },
          {
            text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`,
            style: 'subheader',
          },
          { text: `Date: ${currentDate}`, style: 'subheader' },

          '\n',
          {
            table: {
              headerRows: 1,
              widths: ['auto', '*', 'auto'],
              body: [
                ['No.', 'Email', 'Reason'],
                ...blacklistData.map((entry, index) => [
                  index + 1,
                  { text: entry.email, noWrap: false },
                  { text: entry.reason, noWrap: false },
                ]),
              ],
            },
          },
        ],
        footer: function (currentPage: number, pageCount: number): any {
          return {
            columns: [
              'VITITECH',
              {
                text: 'Page ' + currentPage.toString() + ' of ' + pageCount,
                alignment: 'right' as Alignment,
              },
            ],
            margin: [30, 0] as [number, number],
          };
        },
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10],
          },
        },
      };
    } else {
      documentDefinition = {
        header: {
          image: this.headerString,
          fit: [40, 40] as [number, number],
          alignment: 'center' as Alignment,
        },
        content: [
          { text: 'Blacklist Report', style: 'header' },
          {
            table: {
              headerRows: 1,
              widths: ['auto'],
              body: [['No blacklist entries found.']],
            },
          },
          '\n',
          { text: '*********** Report End ***********', style: 'reportEnd' },
        ],
        footer: function (currentPage: number, pageCount: number): any {
          return {
            columns: [
              'VITITECH',
              {
                text: 'Page ' + currentPage.toString() + ' of ' + pageCount,
                alignment: 'right' as Alignment,
              },
            ],
            margin: [30, 0] as [number, number],
          };
        },
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10],
          },
          subheader: {
            fontSize: 12,
            italics: true,
            margin: [0, 5, 0, 5],
          },
          reportEnd: {
            fontSize: 14,
            bold: true,
            margin: [0, 7, 0, 7],
            alignment: 'center',
          },
        },
      };
    }

    pdfMake
      .createPdf(documentDefinition)
      .download(`blacklist_report_${currentDate}.pdf`);
  }

  generateBlacklist(
    blacklistData: Blacklist[],
    currentDate: string
  ): Promise<Blob> {
    type Alignment = 'left' | 'right' | 'center' | 'justify';
    return new Promise<Blob>(async (resolve, reject) => {
      let documentDefinition: any;
      this.headerString = await this.toBase64('assets/download.png');
      this.toastr.success('Generating...', 'Report');

      if (blacklistData.length > 0) {
        documentDefinition = {
          header: {
            image: this.headerString,
            fit: [40, 40] as [number, number],
            alignment: 'center' as Alignment,
          },
          content: [
            { text: 'Blacklist Report', style: 'header' },
            {
              text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`,
              style: 'subheader',
            },
            { text: `Date: ${currentDate}`, style: 'subheader' },

            '\n',
            {
              table: {
                headerRows: 1,
                widths: ['auto', '*', 'auto'],
                body: [
                  ['No.', 'Email', 'Reason'],
                  ...blacklistData.map((entry, index) => [
                    index + 1,
                    { text: entry.email, noWrap: false },
                    { text: entry.reason, noWrap: false },
                  ]),
                ],
              },
            },
            '\n',
            { text: '*********** Report End ***********', style: 'reportEnd' },
          ],
          footer: function (currentPage: number, pageCount: number): any {
            return {
              columns: [
                'VITITECH',
                {
                  text: 'Page ' + currentPage.toString() + ' of ' + pageCount,
                  alignment: 'right' as Alignment,
                },
              ],
              margin: [30, 0] as [number, number],
            };
          },
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10],
            },
            subheader: {
              fontSize: 12,
              italics: true,
              margin: [0, 5, 0, 5],
            },
            reportEnd: {
              fontSize: 14,
              bold: true,
              margin: [0, 7, 0, 7],
              alignment: 'center',
            },
          },
        };
      } else {
        documentDefinition = {
          header: {
            image: this.headerString,
            fit: [40, 40] as [number, number],
            alignment: 'center' as Alignment,
          },
          content: [
            { text: 'Blacklist Report', style: 'header' },
            {
              table: {
                headerRows: 1,
                widths: ['auto'],
                body: [['No blacklist entries found.']],
              },
            },
          ],
          footer: function (currentPage: number, pageCount: number): any {
            return {
              columns: [
                'VITITECH',
                {
                  text: 'Page ' + currentPage.toString() + ' of ' + pageCount,
                  alignment: 'right' as Alignment,
                },
              ],
              margin: [30, 0] as [number, number],
            };
          },
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10],
            },
          },
        };
      }

      const pdfDocGenerator = pdfMake.createPdf(documentDefinition);

      pdfDocGenerator.getBlob((pdfBlob: Blob) => {
        resolve(pdfBlob);
      });
    });
  }

  //---------------------------------------------------  Blacklist  ----------------------------------------------------------------

  //---------------------------------------------------  Wines  ----------------------------------------------------------------

  async generateWinesReport(
    winesData: Wine[],
    currentDate: string
  ): Promise<Blob> {
    type Alignment = 'left' | 'right' | 'center' | 'justify';
    this.loadWines();
    this.headerString = await this.toBase64('assets/download.png');

    let delay = (ms: number) =>
      new Promise((resolve) => setTimeout(resolve, ms));
    this.toastr.success('Generating...', 'Report');
    await delay(1234);

    return new Promise<Blob>((resolve, reject) => {
      let documentDefinition: any;

      if (winesData.length > 0) {
        console.log(winesData);
        documentDefinition = {
          header: {
            image: this.headerString,
            fit: [40, 40] as [number, number],
            alignment: 'center' as Alignment,
          },
          content: [
            { text: 'Wines Report', style: 'header' },
            {
              text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`,
              style: 'subheader',
            },
            { text: `Date: ${currentDate}`, style: 'subheader' },
            '\n',
            {
              table: {
                headerRows: 1,
                widths: ['auto', '*', 'auto', 'auto', 'auto'],
                body: [
                  ['No.', 'Wine Name', 'Varietal', 'Type', 'Price'],
                  ...winesData.map((item, index) => {
                    const wineActive = item.displayItem ? 'Yes' : 'No';

                    return [
                      index + 1,
                      { text: `${item.name} (${item.vintage})` , noWrap: false } || 'N/A',
                      {
                        text: this.getVarietalName(item.varietalID),
                        noWrap: false,
                      } || 'N/A',
                      {
                        text: this.getWinetypeName(item.wineTypeID),
                        noWrap: false,
                      } || 'N/A',
                      'R ' + item.price || 'N/A',
                    ];
                  }),
                ],
              },
            },
          ],
          footer: function (currentPage: number, pageCount: number): any {
            return {
              columns: [
                'VITITECH',
                {
                  text: 'Page ' + currentPage.toString() + ' of ' + pageCount,
                  alignment: 'right' as Alignment,
                },
              ],
              margin: [30, 0] as [number, number],
            };
          },
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10],
            },
            subheader: {
              fontSize: 12,
              italics: true,
              margin: [0, 5, 0, 5],
            },
          },
        };
      } else {
        documentDefinition = {
          header: {
            image: this.headerString,
            fit: [40, 40] as [number, number],
            alignment: 'center' as Alignment,
          },
          content: [
            { text: 'Wine Report', style: 'header' },
            {
              table: {
                headerRows: 1,
                widths: ['auto'],
                body: [['No wine items found.']],
              },
            },
          ],
          footer: function (currentPage: number, pageCount: number): any {
            return {
              columns: [
                'VITITECH',
                {
                  text: 'Page ' + currentPage.toString() + ' of ' + pageCount,
                  alignment: 'right' as Alignment,
                },
              ],
              margin: [30, 0] as [number, number],
            };
          },
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10],
            },
          },
        };
      }

      const pdfDocGenerator = pdfMake.createPdf(documentDefinition);

      pdfDocGenerator.getBlob((pdfBlob: Blob) => {
        resolve(pdfBlob);
      });
    });
  }

  async generateWinesReportpdf(
    winesData: Wine[],
    currentDate: string
  ): Promise<Blob> {
    type Alignment = 'left' | 'right' | 'center' | 'justify';
    this.loadWines();
    this.headerString = await this.toBase64('assets/download.png');

    const delay = (ms: number) =>
      new Promise((resolve) => setTimeout(resolve, ms));
    this.toastr.success('Generating...', 'Report');
    await delay(1234);
    return new Promise<Blob>((resolve, reject) => {
      let documentDefinition: any;

      if (winesData.length > 0) {
        console.log(winesData);
        documentDefinition = {
          header: {
            image: this.headerString,
            fit: [40, 40] as [number, number],
            alignment: 'center' as Alignment,
          },
          content: [
            { text: 'Wines Report', style: 'header' },
            {
              text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`,
              style: 'subheader',
            },
            { text: `Date: ${currentDate}`, style: 'subheader' },
            '\n',
            {
              table: {
                headerRows: 1,
                widths: ['auto', '*', 'auto', 'auto', 'auto'],
                body: [
                  ['No.', 'Wine Name', 'Varietal', 'Type', 'Price'],
                  ...winesData.map((item, index) => {

                    return [
                      index + 1,
                      { text: `${item.name} (${item.vintage})`, noWrap: false } || 'N/A',
                      {
                        text: this.getVarietalName(item.varietalID),
                        noWrap: false,
                      } || 'N/A',
                      {
                        text: this.getWinetypeName(item.wineTypeID),
                        noWrap: false,
                      } || 'N/A',
                      'R ' + item.price || 'N/A',
                    ];
                  }),
                ],
              },
            },
          ],
          footer: function (currentPage: number, pageCount: number): any {
            return {
              columns: [
                'VITITECH',
                {
                  text: 'Page ' + currentPage.toString() + ' of ' + pageCount,
                  alignment: 'right' as Alignment,
                },
              ],
              margin: [30, 0] as [number, number],
            };
          },
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10],
            },
            subheader: {
              fontSize: 12,
              italics: true,
              margin: [0, 5, 0, 5],
            },
          },
        };
      } else {
        documentDefinition = {
          header: {
            image: this.headerString,
            fit: [40, 40] as [number, number],
            alignment: 'center' as Alignment,
          },
          content: [
            { text: 'Wine Report', style: 'header' },
            {
              table: {
                headerRows: 1,
                widths: ['auto'],
                body: [['No wine items found.']],
              },
            },
          ],
          footer: function (currentPage: number, pageCount: number): any {
            return {
              columns: [
                'VITITECH',
                {
                  text: 'Page ' + currentPage.toString() + ' of ' + pageCount,
                  alignment: 'right' as Alignment,
                },
              ],
              margin: [30, 0] as [number, number],
            };
          },
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10],
            },
          },
        };
      }

      pdfMake
        .createPdf(documentDefinition)
        .download(`wines_report_${currentDate}.pdf`);
    });
  }

  //---------------------------------------------------  Wines  ----------------------------------------------------------------

  async toBase64(url: string): Promise<string> {
    return new Promise<string>((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.onload = function () {
        const reader = new FileReader();
        reader.onloadend = function () {
          console.log(reader.result);
          resolve(reader.result as string);
        };
        reader.readAsDataURL(xhr.response);
      };
      xhr.open('GET', url);
      xhr.responseType = 'blob';
      xhr.send();
    });
  }
}
