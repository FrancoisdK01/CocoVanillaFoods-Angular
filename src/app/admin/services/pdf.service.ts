import { Injectable } from '@angular/core';
import pdfMake from 'pdfmake/build/pdfmake';
import pdfFonts from 'pdfmake/build/vfs_fonts';
import { Inventory } from 'src/app/Model/inventory';
import { DataServiceService } from 'src/app/customer/services/data-service.service';
import { Event } from 'src/app/Model/event';
import { SupplierOrder } from 'src/app/Model/supplierOrder';
import { Blacklist } from 'src/app/Model/blacklist';
import { Wine } from 'src/app/Model/wine';
import { WineType } from 'src/app/Model/winetype';
import { Varietal } from 'src/app/Model/varietal';
import { ToastrService } from 'ngx-toastr';
import { WineService } from '../services/wine.service';
import { WinetypeService } from './winetype.service';
import { VarietalService } from './varietal.service';
import { SupplierService } from './supplier.service';
import { style } from '@angular/animations';
import { SuppOrderAndVATViewModel } from 'src/app/Model/SupplierOrdersVATs';


pdfMake.vfs = pdfFonts.pdfMake.vfs;

@Injectable({
  providedIn: 'root'
})
export class PdfService {
  user: any;
  blacklistData: any;

  constructor(private userService: DataServiceService,
    private wineService: WineService,
    private winetypeService: WinetypeService,
    private varietalService: VarietalService,
    private supplierService: SupplierService,
    private toastr: ToastrService) {
    var tokenUser = this.userService.getUserFromToken();
    this.userService.getUser(tokenUser!.email).subscribe((result: any) => {
      this.user = result.user;
    })
  }
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  //Inventory Report 
  wines: Wine[] = [];
  allWines: Wine[] = [];
  winetypes: WineType[] = [];
  varietals: Varietal[] = [];
  searchQuery: string = '';

  getWineName(wineID: number): string {
    console.log('Name ID', wineID)
    let wine = this.wines.find(x => x.wineID == wineID);
    console.log('Wine', wine)
    return wine ? wine.name : 'Unknown';
  }

  getVarietalName(varietalID: number): string {
    console.log('V ID', varietalID)
    let varietal = this.varietals.find(x => x.varietalID == varietalID);
    return varietal?.name || 'Unknown';
  }

  getWinetypeName(wineTypeID?: number): string {
    console.log('Type ID', wineTypeID)
    let winetype = this.winetypes.find(x => x.wineTypeID == wineTypeID);
    return winetype?.name || 'Unknown';
  }

  async loadWines(): Promise<void> {
    try {
      this.allWines = await this.wineService.getWines();
      console.log('All Wines:', this.allWines);
      this.winetypes = await this.winetypeService.getWinetypes();
      this.varietals = await this.varietalService.getVarietals();
      this.filterWines();
    } catch (error) {
      console.error(error);
      this.toastr.error('Error, please try again', 'Wine Table');
    }
  }

  filterWines(): void {
    if (this.searchQuery.trim() !== '') {
      const query = this.searchQuery.toLowerCase().trim();
      this.wines = this.allWines.filter(wine =>
        wine.name.toLowerCase().includes(query) ||
        wine.vintage.toString().includes(query) ||
        wine.varietalID.toString().includes(query) ||
        wine.wineTypeID.toString().includes(query) ||
        wine.winePrice.toString().includes(query)
      );
    } else {
      this.wines = [...this.allWines]; // if searchQuery is empty, show all wines
    }
  }


  async generateInventoryPdf(inventoryData: Inventory[], currentDate: string): Promise<Blob> {
    this.loadWines();

    const delay = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

  await delay(50);
  // if(this.getWineName(inventoryData.wineID) == 'Unknown'){

  // }

  return new Promise<Blob>((resolve, reject) => {
    let documentDefinition: any;

    if (inventoryData.length > 0) {
      console.log(inventoryData)
      documentDefinition = {
        content: [
          { text: 'Inventory Report', style: 'header' },
          { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
          { text: `Date generated: ${currentDate}`, style: 'subheader' },
          '\n',
          {
            table: {
              headerRows: 1,
              widths: ['auto', '*', 'auto', 'auto', 'auto', 'auto', 'auto'],
              body: [
                ['No.', 'Wine Name', 'Wine Varietal', 'Wine Type', 'Wine Price', 'Stock Limit', 'Quantity on Hand'],
                ...inventoryData.map((item, index) => [
                  index + 1,
                  this.getWineName(item.wineID) || 'N/A',
                  this.getVarietalName(item.varietalID) || 'N/A',
                  this.getWinetypeName(item.wineTypeID) || 'N/A',
                  'R ' + item.winePrice || 'N/A',
                  item.stockLimit || 'N/A',
                  item.quantityOnHand || 'N/A'
                ])
              ]
            }
          }
        ],
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10]
          },
          subheader: {
            fontSize: 12,
            italics: true,
            margin: [0, 5, 0, 5]
          }
        }
      };
    } else {
      documentDefinition = {
        content: [
          { text: 'Inventory Report', style: 'header' },
          { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
          { text: `Date: ${currentDate}`, style: 'subheader' },
          '\n',
          {
            table: {
              headerRows: 1,
              widths: ['auto'],
              body: [
                ["There is nothing stored in Inventory at the moment."]
              ]
            }
          }
        ],
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10]
          },
          subheader: {
            fontSize: 12,
            italics: true,
            margin: [0, 5, 0, 5]
          }
        }
      };
    }

    pdfMake.createPdf(documentDefinition).download('inventory_report.pdf');
  })
  }

 async  generateInventoryReport(inventoryData: Inventory[], currentDate: string): Promise<Blob> {
    this.loadWines();
    const delay = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

  await delay(50);
    return new Promise<Blob>((resolve, reject) => {
      let documentDefinition: any;
  
      if (inventoryData.length > 0) {
        console.log(inventoryData)
        documentDefinition = {
          content: [
            { text: 'Inventory Report', style: 'header' },
            { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
            { text: `Date generated: ${currentDate}`, style: 'subheader' },
            '\n',
            {
              table: {
                headerRows: 1,
                widths: ['auto', '*', 'auto', 'auto', 'auto', 'auto', 'auto'],
                body: [
                  ['No.', 'Wine Name', 'Wine Varietal', 'Wine Type', 'Wine Price', 'Stock Limit', 'Quantity on Hand'],
                  ...inventoryData.map((item, index) => [
                    index + 1,
                    this.getWineName(item.wineID) || 'N/A',
                    this.getVarietalName(item.varietalID) || 'N/A',
                    this.getWinetypeName(item.wineTypeID) || 'N/A',
                    'R ' + item.winePrice || 'N/A',
                    item.stockLimit || 'N/A',
                    item.quantityOnHand || 'N/A'
                  ])
                ]
              }
            }
          ],
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10]
            },
            subheader: {
              fontSize: 12,
              italics: true,
              margin: [0, 5, 0, 5]
            }
          }
        };
      } else {
        documentDefinition = {
          content: [
            { text: 'Inventory Report', style: 'header' },
            {
              table: {
                headerRows: 1,
                widths: ['auto'],
                body: [['No inventory items found.']],
              },
            },
          ],
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10],
            },
          },
        };
      }
  
      const pdfDocGenerator = pdfMake.createPdf(documentDefinition);
  
      pdfDocGenerator.getBlob((pdfBlob: Blob) => {
        resolve(pdfBlob);
      });
    });
  }
  



  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  // generateRefundsPdf(refundData: RefundRequest[], beginDate: Date, endDate: Date): void {
  //   let beginDate2 = new Date(beginDate);
  //   let endDate2 = new Date(endDate);

  //   let formattedBeginDate = `${beginDate2.getDate()}-${beginDate2.getMonth() + 1}-${beginDate2.getFullYear()}`;
  //   let formattedEndDate = `${endDate2.getDate()}-${endDate2.getMonth() + 1}-${endDate2.getFullYear()}`;

  //   let documentDefinition: any;

  //   if (refundData.length > 0) {
  //     documentDefinition = {
  //       content: [
  //         { text: 'Refunds Report', style: 'header' },
  //         { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
  //         { text: `From: ${formattedBeginDate} To: ${formattedEndDate}`, style: 'subheader' },
  //         {
  //           table: {
  //             headerRows: 1,
  //             widths: ['auto', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto'],
  //             body: [
  //               ['No.', 'WineId', 'OrderId', 'Reference Number', 'Requested On', 'Description', 'Email', 'Status'],
  //               ...refundData.map((item, index) => {
  //                 let status = 'Pending'; // Status for each row
  //                 if (item.status == 0) {
  //                   status = "In Progress";
  //                 } else if (item.status == 1) {
  //                   status = "Approved";
  //                 } else if (item.status == 2) {
  //                   status = "Not Approved";
  //                 }

  //                 return [index, item.wineId, item.orderId, item.orderRefNum, item.requestedOn, item.description, item.email, status];
  //               })
  //             ]
  //           }
  //         }
  //       ],
  //       styles: {
  //         header: {
  //           fontSize: 16,
  //           bold: true,
  //           margin: [0, 10]
  //         },
  //         subheader: {
  //           fontSize: 12,
  //           margin: [0, 6]
  //         }
  //       },
  //       pageOrientation: 'landscape'
  //     };
  //   } else {
  //     documentDefinition = {
  //       content: [
  //         { text: 'Refunds Report', style: 'header' },
  //         { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
  //         { text: `From: ${formattedBeginDate} To: ${formattedEndDate}`, style: 'subheader' },
  //         {
  //           table: {
  //             headerRows: 1,
  //             widths: ['auto'],
  //             body: [
  //               ["There were no refunds between the selected dates."]
  //             ]
  //           }
  //         }
  //       ],
  //       styles: {
  //         header: {
  //           fontSize: 16,
  //           bold: true,
  //           margin: [0, 10]
  //         },
  //         subheader: {
  //           fontSize: 12,
  //           margin: [0, 6]
  //         }
  //       },
  //       pageOrientation: 'landscape'
  //     };
  //   }

  //   pdfMake.createPdf(documentDefinition).download(`refunds_report_${formattedBeginDate}_${formattedEndDate}.pdf`);
  // }


  // generateRefundReport(refundData: RefundRequest[], currentDate: string): Promise<Blob> {
  //   return new Promise<Blob>((resolve, reject) => {
  //     let documentDefinition: any;
  
  //     if (refundData.length > 0) {
  //       documentDefinition = {
  //         content: [
  //           { text: 'Refunds Report', style: 'header' },
  //           { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
  //           { text: `From: ${formattedBeginDate} To: ${formattedEndDate}`, style: 'subheader' },
  //           {
  //             table: {
  //               headerRows: 1,
  //               widths: ['auto', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto'],
  //               body: [
  //                 ['No.', 'WineId', 'OrderId', 'Reference Number', 'Requested On', 'Description', 'Email', 'Status'],
  //                 ...refundData.map((item, index) => {
  //                   let status = 'Pending'; // Status for each row
  //                   if (item.status == 0) {
  //                     status = "In Progress";
  //                   } else if (item.status == 1) {
  //                     status = "Approved";
  //                   } else if (item.status == 2) {
  //                     status = "Not Approved";
  //                   }
  
  //                   return [index, item.wineId, item.orderId, item.orderRefNum, item.requestedOn, item.description, item.email, status];
  //                 })
  //               ]
  //             }
  //           }
  //         ],
  //         styles: {
  //           header: {
  //             fontSize: 16,
  //             bold: true,
  //             margin: [0, 10]
  //           },
  //           subheader: {
  //             fontSize: 12,
  //             margin: [0, 6]
  //           }
  //         },
  //         pageOrientation: 'landscape'
  //       };
  //     } else {
  //       documentDefinition = {
  //         content: [
  //           { text: 'Refund Report', style: 'header' },
  //           {
  //             table: {
  //               headerRows: 1,
  //               widths: ['auto'],
  //               body: [['No refunds available.']],
  //             },
  //           },
  //         ],
  //         styles: {
  //           header: {
  //             fontSize: 16,
  //             bold: true,
  //             margin: [0, 10, 0, 10],
  //           },
  //         },
  //       };
  //     }
  
  //     const pdfDocGenerator = pdfMake.createPdf(documentDefinition);
  
  //     pdfDocGenerator.getBlob((pdfBlob: Blob) => {
  //       resolve(pdfBlob);
  //     });
  //   });
  // }



  //---------------------------------------------------  Events  ----------------------------------------------------------------



  generateEventsPdf(eventData: Event[], beginDate: Date, endDate: Date): void {
    let formattedBeginDate = new Date(beginDate).toLocaleDateString();
    let formattedEndDate = new Date(endDate).toLocaleDateString();
    let generatedDate = Date.now();

    let documentDefinition: any;

    if (eventData.length > 0) {
      documentDefinition = {
        content: [
          { text: 'Events Report', style: 'header' },
          { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
          { text: `Generated On: ${new Date(generatedDate).toLocaleDateString()}`, style: 'subheader' },
          { text: `Time Period: ${formattedBeginDate} -- ${formattedEndDate}`, style: 'subheader' },
          '\n',
          {
            table: {
                headerRows: 1,
                widths: ['auto', '*', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto'], 
                body: [
                    ['No.', 'Name', 'Date', 'Tickets Available', 'Tickets Sold', 'Price', 'Early Bird Discount', 'Revenue', 'Active'],
                    ...eventData.map((event, index) => {
        
                        const eventEarlyBirdlimit = event.earlyBird?.limit || 0;  // Default to 0 if null
                        const eventEarlyBirdPercentage = event.earlyBird?.percentage || 0;  // Default to 0 if null
                        const eventActive = event.displayEvent ? "Yes" : "No"; 
        
                        const earlyBirdPrice = event.eventPrice - (event.eventPrice * eventEarlyBirdPercentage / 100);
                        const earlyBirdDiscountAmount = event.eventPrice - earlyBirdPrice;  // Calculating discount amount
        
                        const earlyBirdTicketsSold = event.tickets_Sold <= eventEarlyBirdlimit ? event.tickets_Sold : eventEarlyBirdlimit;
                        const regularTicketsSold = event.tickets_Sold - earlyBirdTicketsSold;
        
                        const revenueFromEarlyBirdTickets = earlyBirdTicketsSold * earlyBirdPrice;
                        const revenueFromRegularTickets = regularTicketsSold * event.eventPrice;
                        const totalRevenue = revenueFromEarlyBirdTickets + revenueFromRegularTickets;
        
                        return [
                            index + 1,
                            event.eventName,
                            new Date(event.eventDate).toLocaleDateString(),
                            event.tickets_Available,
                            event.tickets_Sold,
                            `R${event.eventPrice}`,
                            `R${earlyBirdDiscountAmount.toFixed(2)}`,  // Added "Early Bird Discount" column value and fixed it to two decimal places
                            `R${totalRevenue.toFixed(2)}`, // Fixing to two decimal places for cleaner display
                            eventActive
                        ];
                    })
                ]
            }
        }
        

        ],
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10]
          },
          subheader: {
            fontSize: 12,
            italics: true,
            margin: [0, 5, 0, 5]
          }
        }
      };
    } else {
      documentDefinition = {
        content: [
          { text: 'Events Report', style: 'header' },
          { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
          { text: `From: ${formattedBeginDate} To: ${formattedEndDate}`, style: 'subheader' },
          '\n',
          {
            table: {
              headerRows: 1,
              widths: ['auto'],
              body: [
                ["There are no events between the specified dates."]
              ]
            }
          }
        ],
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10]
          },
          subheader: {
            fontSize: 12,
            italics: true,
            margin: [0, 5, 0, 5]
          }
        }
      };
    }

    pdfMake.createPdf(documentDefinition).download(`events_report_${formattedBeginDate}_${formattedEndDate}.pdf`);
  }

  generateEventsReport(eventData: Event[], beginDate: Date, endDate: Date, currentDate: string): Promise<Blob> {
    return new Promise<Blob>((resolve, reject) => {
      let documentDefinition: any;
      let formattedBeginDate = new Date(beginDate).toLocaleDateString();
      let formattedEndDate = new Date(endDate).toLocaleDateString();
      let generatedDate = Date.now();
  
      if (eventData.length > 0) {
        documentDefinition = {
          content: [
            { text: 'Events Report', style: 'header' },
            { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
            { text: `Generated On: ${new Date(generatedDate).toLocaleDateString()}`, style: 'subheader' },
            { text: `Time Period: ${formattedBeginDate} -- ${formattedEndDate}`, style: 'subheader' },
            '\n',
            {
              table: {
                  headerRows: 1,
                  widths: ['auto', '*', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto'], 
                  body: [
                      ['No.', 'Name', 'Date', 'Tickets Available', 'Tickets Sold', 'Price', 'Early Bird Discount', 'Revenue', 'Active'],
                      ...eventData.map((event, index) => {
          
                          const eventEarlyBirdlimit = event.earlyBird?.limit || 0;  // Default to 0 if null
                          const eventEarlyBirdPercentage = event.earlyBird?.percentage || 0;  // Default to 0 if null
                          const eventActive = event.displayEvent ? "Yes" : "No"; 
          
                          const earlyBirdPrice = event.eventPrice - (event.eventPrice * eventEarlyBirdPercentage / 100);
                          const earlyBirdDiscountAmount = event.eventPrice - earlyBirdPrice;  // Calculating discount amount
          
                          const earlyBirdTicketsSold = event.tickets_Sold <= eventEarlyBirdlimit ? event.tickets_Sold : eventEarlyBirdlimit;
                          const regularTicketsSold = event.tickets_Sold - earlyBirdTicketsSold;
          
                          const revenueFromEarlyBirdTickets = earlyBirdTicketsSold * earlyBirdPrice;
                          const revenueFromRegularTickets = regularTicketsSold * event.eventPrice;
                          const totalRevenue = revenueFromEarlyBirdTickets + revenueFromRegularTickets;
          
                          return [
                              index + 1,
                              event.eventName,
                              new Date(event.eventDate).toLocaleDateString(),
                              event.tickets_Available,
                              event.tickets_Sold,
                              `R${event.eventPrice}`,
                              `R${earlyBirdDiscountAmount.toFixed(2)}`,  // Added "Early Bird Discount" column value and fixed it to two decimal places
                              `R${totalRevenue.toFixed(2)}`, // Fixing to two decimal places for cleaner display
                              eventActive
                          ];
                      })
                  ]
              }
          }
          
  
          ],
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10]
            },
            subheader: {
              fontSize: 12,
              italics: true,
              margin: [0, 5, 0, 5]
            }
          }
        };
      } else {
        documentDefinition = {
          content: [
            { text: 'Events Report', style: 'header' },
            {
              table: {
                headerRows: 1,
                widths: ['auto'],
                body: [['No events available.']],
              },
            },
          ],
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10],
            },
          },
        };
      }
  
      const pdfDocGenerator = pdfMake.createPdf(documentDefinition);
  
      pdfDocGenerator.getBlob((pdfBlob: Blob) => {
        resolve(pdfBlob);
      });
    });
  }
  
  


  //---------------------------------------------------  Events  ----------------------------------------------------------------
  async generateSupplierOrdersPdf(supplierOrderData: SuppOrderAndVATViewModel[]): Promise<void> {
    console.log(supplierOrderData);
    if (!supplierOrderData || supplierOrderData.length === 0) {
      this.toastr.error("No supplier order data provided.");
      return;
  }

  console.log('Supplier Order Data:', supplierOrderData);

  let generatedDate = Date.now();
  let supplierTotals: { [key: string]: number } = {};

  // Extract VAT percentage
  if (!supplierOrderData[0].vaTs?.percentage) {
      this.toastr.error("No vat data in your request, please ensure that you have a VAT percentage in your system")
      return;
  }
  const vatPercentage = supplierOrderData[0].vaTs.percentage ?? 0.15; // Convert to a proportion for calculation
      let body: any[] = [
          ['#', 'Supplier Name', 'Wine Name', 'Quantity Ordered', 'Order Cost', `VAT (${supplierOrderData[0].vaTs.percentage}%)`, 'Sub-Total']
      ];
      let supplierTotalBody: any[] = [
        ['Supplier Name', 'Total Amount Paid']
      ];

      let grandTotal = 0;
      const flattenedSupplierOrders = supplierOrderData.flatMap(data => 
        data.supplierOrders || []
      ).filter(order => !!order);

      flattenedSupplierOrders.forEach((order, index) => {
        const vat = (order.orderTotal ?? 0) * vatPercentage / 100;  
        const totalWithVat = (order.orderTotal ?? 0) + vat;

        supplierTotals[order.supplierID!] = (supplierTotals[order.supplierID!] || 0) + totalWithVat;
      });


      Promise.all(
        flattenedSupplierOrders.map(order => {
          return new Promise<string>((resolve, reject) => {
            this.supplierService.getSupplier(order.supplierID!).subscribe(
              (result: any) => resolve(result.name),
              error => reject(error)
            );
          });
        })
      ).then(supplierNames => {
        flattenedSupplierOrders.forEach((order, index) => {
          const vat = (order.orderTotal ?? 0) * vatPercentage/100;  // Use extracted VAT percentage for calculation
          const totalWithVat = (order.orderTotal ?? 0) + vat;
          grandTotal += totalWithVat;
          const quantityOrdered = order.quantity_Ordered ?? 0;
  
          body.push([
            index + 1,
            supplierNames[index],
            order.wineName,
            quantityOrdered,
            "R " + (order.orderTotal ?? 0).toFixed(2),
            `R ${vat.toFixed(2)}`,
            `R ${totalWithVat.toFixed(2)}`
          ]);
        });

        let addedSuppliers = new Set<string>();

        flattenedSupplierOrders.forEach((order, index) => {
          if (order.supplierID !== undefined) {
            const supplierIDStr = String(order.supplierID);
            if (!addedSuppliers.has(supplierIDStr)) {
              supplierTotalBody.push([
                supplierNames[index],
                `R ${supplierTotals[order.supplierID].toFixed(2)}`,
              ]);
              addedSuppliers.add(supplierIDStr);
            }
          }
        });

        // After you've added all suppliers and their totals, add the grand total:
        supplierTotalBody.push(["", `R ${grandTotal.toFixed(2)}`]);


          body.push(
              [{}, {}, {}, {}, {}, { text: 'Grand Total:', bold: true }, { text: `R ${grandTotal.toFixed(2)}`, bold: true }]
          );

          type Alignment = 'left' | 'right' | 'center' | 'justify';

          const documentDefinition = {
              content: [
                  { text: 'Supplier Order Report', style: 'header' },
                  { text: `Generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
                  { text: `Generated On: ${new Date(generatedDate).toLocaleDateString()}`, style: 'subheader' },
                  '\n',
                  {
                      table: {
                          headerRows: 1,
                          widths: ['5%', '13%', '16%', '11%', '18%', '15%', '22%'],
                          body: body
                      },
                      layout: {
                          fillColor: function (rowIndex: number, node: any, columnIndex: number) {
                              return rowIndex === body.length - 1 ? '#DDDDDD' : null;  // grey background for the last row
                          }
                      }
                  },
                  '\n',
                  '\n',  // Space between tables
                  {
                    table: {
                      widths: ['70%', '30%'],
                      body: supplierTotalBody
                    },
                    layout: {
                      fillColor: function (rowIndex: number, node: any, columnIndex: number) {
                        return rowIndex === supplierTotalBody.length - 1 ? '#DDDDDD' : null;  // grey background for the last row
                      }
                    }
                  }
              ],
              styles: {
                  header: {
                      fontSize: 16,
                      bold: true,
                      margin: [0, 0, 10, 0] as [number, number, number, number]
                  },
                  subheader: {
                      fontSize: 12,
                      margin: [0, 0, 6, 0] as [number, number, number, number],
                      alignment: 'left' as Alignment
                  }
              },
              pageOrientation: 'portrait' as const
          }
          pdfMake.createPdf(documentDefinition).download(`supplier_order_report_${generatedDate}.pdf`);
      });
}
  

async generateSupplierOrders(supplierOrderData: SuppOrderAndVATViewModel[]): Promise<Blob> {
  return new Promise<Blob>((resolve, reject) => {
      console.log('SupplierOrder And VAT:', supplierOrderData);
      let generatedDate = Date.now();
      let supplierTotals: { [key: string]: number } = {};

      // Extract VAT percentage
      if (!supplierOrderData[0] || !supplierOrderData[0].vaTs) {
        reject('Missing VAT data');
        return;
      }
      const vatPercentage = supplierOrderData[0].vaTs.percentage ?? 0.15; // Convert to a proportion for calculation

      let body: any[] = [
          ['#', 'Supplier Name', 'Wine Name', 'Quantity Ordered', 'Order Cost', `VAT (${supplierOrderData[0].vaTs.percentage}%)`, 'Sub-Total']
      ];
      let supplierTotalBody: any[] = [
        ['Supplier Name', 'Total Amount Paid']
      ];

      let grandTotal = 0;
      const flattenedSupplierOrders = supplierOrderData.flatMap(data => 
        data.supplierOrders || []
      ).filter(order => !!order);

      Promise.all(
        flattenedSupplierOrders.map(order => {
          return new Promise<string>((resolve, reject) => {
            this.supplierService.getSupplier(order.supplierID!).subscribe(
              (result: any) => resolve(result.name),
              error => reject(error)
            );
          });
        })
      ).then(supplierNames => {
        flattenedSupplierOrders.forEach((order, index) => {
          const vat = (order.orderTotal ?? 0) * vatPercentage/100;  // Use extracted VAT percentage for calculation
          const totalWithVat = (order.orderTotal ?? 0) + vat;
          grandTotal += totalWithVat;
          const quantityOrdered = order.quantity_Ordered ?? 0;
  
          body.push([
            index + 1,
            supplierNames[index],
            order.wineName,
            quantityOrdered,
            "R " + (order.orderTotal ?? 0).toFixed(2),
            `R ${vat.toFixed(2)}`,
            `R ${totalWithVat.toFixed(2)}`
          ]);
        });

        let addedSuppliers = new Set<string>();

        flattenedSupplierOrders.forEach((order) => {
          const vat = (order.orderTotal ?? 0) * vatPercentage / 100;
          const totalWithVat = (order.orderTotal ?? 0) + vat;
      
          if (order.supplierID !== undefined) {
              if (!supplierTotals[order.supplierID]) {
                  supplierTotals[order.supplierID] = 0;  // Initialize if not already set
              }
              supplierTotals[order.supplierID] += totalWithVat;  // Add to the supplier's total
          }
      });
      
        
      flattenedSupplierOrders.forEach((order, index) => {
        if (order.supplierID !== undefined) {
            const supplierIDStr = String(order.supplierID);
            if (!addedSuppliers.has(supplierIDStr)) {
                supplierTotalBody.push([
                    supplierNames[index],
                    `R ${supplierTotals[order.supplierID].toFixed(2)}`,
                ]);
                addedSuppliers.add(supplierIDStr);
            }
        }
    });
    

        // After you've added all suppliers and their totals, add the grand total:
        supplierTotalBody.push(["", `R ${grandTotal.toFixed(2)}`]);


          body.push(
              [{}, {}, {}, {}, {}, { text: 'Grand Total:', bold: true }, { text: `R ${grandTotal.toFixed(2)}`, bold: true }]
          );

          type Alignment = 'left' | 'right' | 'center' | 'justify';

          const documentDefinition = {
              content: [
                  { text: 'Supplier Order Report', style: 'header' },
                  { text: `Generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
                  { text: `Generated On: ${new Date(generatedDate).toLocaleDateString()}`, style: 'subheader' },
                  '\n',
                  {
                      table: {
                          headerRows: 1,
                          widths: ['5%', '13%', '16%', '11%', '18%', '15%', '22%'],
                          body: body
                      },
                      layout: {
                          fillColor: function (rowIndex: number, node: any, columnIndex: number) {
                              return rowIndex === body.length - 1 ? '#DDDDDD' : null;  // grey background for the last row
                          }
                      }
                  },
                  '\n',
                  '\n',  // Space between tables
                  {
                    table: {
                      widths: ['70%', '30%'],
                      body: supplierTotalBody
                    },
                    layout: {
                      fillColor: function (rowIndex: number, node: any, columnIndex: number) {
                        return rowIndex === supplierTotalBody.length - 1 ? '#DDDDDD' : null;  // grey background for the last row
                      }
                    }
                  }
              ],
              styles: {
                  header: {
                      fontSize: 16,
                      bold: true,
                      margin: [0, 0, 10, 0] as [number, number, number, number]
                  },
                  subheader: {
                      fontSize: 12,
                      margin: [0, 0, 6, 0] as [number, number, number, number],
                      alignment: 'left' as Alignment
                  }
              },
              pageOrientation: 'portrait' as const
          };

          const pdfDocGenerator = pdfMake.createPdf(documentDefinition);

          pdfDocGenerator.getBlob((pdfBlob: Blob) => {
              resolve(pdfBlob);
          });
      });
  });
}





  

    //---------------------------------------------------  Blacklist  ----------------------------------------------------------------

  generateBlacklistPdf(blacklistData: Blacklist[], currentDate: string): void {
    let documentDefinition: any;

    if (blacklistData.length > 0) {
      documentDefinition = {
        content: [
          { text: 'Blacklist Report', style: 'header' },
          { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
          { text: `Date: ${currentDate}`, style: 'subheader' },

          '\n',
          {
            table: {
              headerRows: 1,
              widths: ['auto', '*', 'auto'],
              body: [
                ['No.', 'Email', 'Reason'],
                ...blacklistData.map((entry, index) => [

                  index + 1,
                  entry.email,
                  entry.reason,
                ]),
              ],
            },
          },
        ],
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10],
          },
        },
      };
    } else {
      documentDefinition = {
        content: [
          { text: 'Blacklist Report', style: 'header' },
          {
            table: {
              headerRows: 1,
              widths: ['auto'],
              body: [['No blacklist entries found.']],
            },
          },
        ],
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10],
          },
        },
      };
    }

    pdfMake.createPdf(documentDefinition).download(`blacklist_report.pdf`);
  }

  generateBlacklist(blacklistData: Blacklist[], currentDate: string): Promise<Blob> {
    return new Promise<Blob>((resolve, reject) => {
      let documentDefinition: any;

      if (blacklistData.length > 0) {
        documentDefinition = {
          content: [
            { text: 'Blacklist Report', style: 'header' },
            { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
            { text: `Date: ${currentDate}`, style: 'subheader' },
            
            '\n',
            {
              table: {
                headerRows: 1,
                widths: ['auto', '*', 'auto'],
                body: [
                  ['No.', 'Email', 'Reason'],
                  ...blacklistData.map((entry, index) => [
                    index + 1,
                    entry.email,
                    entry.reason,
                  ]),
                ],
              },
            },
          ],
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10],
            },
          },
        };
      } else {
        documentDefinition = {
          content: [
            { text: 'Blacklist Report', style: 'header' },
            {
              table: {
                headerRows: 1,
                widths: ['auto'],
                body: [['No blacklist entries found.']],
              },
            },
          ],
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10],
            },
          },
        };
      }

      const pdfDocGenerator = pdfMake.createPdf(documentDefinition);

      pdfDocGenerator.getBlob((pdfBlob: Blob) => {
        resolve(pdfBlob);
      });
    });
  }






async generateWinesReport(winesData: Wine[], currentDate: string): Promise<Blob> {
  this.loadWines();

  let delay = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

  await delay(50);

  if( this.getVarietalName(winesData[0].varietalID) == 'Unknown' || this.getWinetypeName(winesData[0].wineTypeID) == 'Unknown'){
    this.toastr.error('Will Display Unknown','Could not Get Varietal and Wine Type')

    let delay = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

  await delay(1000);
return new Promise<Blob>((resolve, reject) => {
  let documentDefinition: any;

  if (winesData.length > 0) {
    console.log(winesData)
    documentDefinition = {
      content: [
        { text: 'Wines Report', style: 'header' },
        { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
        { text: `Date: ${currentDate}`, style: 'subheader' },
        '\n',
        {
          table: {
            headerRows: 1,
            widths: ['auto', '*', 'auto', 'auto', 'auto', 'auto'],
            body: [
              ['No.', 'Wine Name', 'Varietal', 'Type', 'Price', 'Active'],
              ...winesData.map((item, index) => {

                const wineActive = item.displayWine ? "Yes" : "No"; 

                return [
                index + 1,
                item.name|| 'N/A',
                this.getVarietalName(item.varietalID) || 'N/A',
                this.getWinetypeName(item.wineTypeID) || 'N/A',
                'R ' + item.winePrice || 'N/A',
                wineActive
              ];
            })
            ]
          }
        }
      ],
      styles: {
        header: {
          fontSize: 16,
          bold: true,
          margin: [0, 10, 0, 10]
        },
        subheader: {
          fontSize: 12,
          italics: true,
          margin: [0, 5, 0, 5]
        }
      }
    };
  } else {
    documentDefinition = {
      content: [
        { text: 'Wine Report', style: 'header' },
        {
          table: {
            headerRows: 1,
            widths: ['auto'],
            body: [['No wine items found.']],
          },
        },
      ],
      styles: {
        header: {
          fontSize: 16,
          bold: true,
          margin: [0, 10, 0, 10],
        },
      },
    };
  }

  const pdfDocGenerator = pdfMake.createPdf(documentDefinition);

  pdfDocGenerator.getBlob((pdfBlob: Blob) => {
    resolve(pdfBlob);
  });
});
  }else{  
  return new Promise<Blob>((resolve, reject) => {
    let documentDefinition: any;

    if (winesData.length > 0) {
      console.log(winesData)
      documentDefinition = {
        content: [
          { text: 'Wines Report', style: 'header' },
          { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
          { text: `Date: ${currentDate}`, style: 'subheader' },
          '\n',
          {
            table: {
              headerRows: 1,
              widths: ['auto', '*', 'auto', 'auto', 'auto', 'auto'],
              body: [
                ['No.', 'Wine Name', 'Varietal', 'Type', 'Price', 'Active'],
                ...winesData.map((item, index) => {

                  const wineActive = item.displayWine ? "Yes" : "No"; 

                  return [
                  index + 1,
                  item.name|| 'N/A',
                  this.getVarietalName(item.varietalID) || 'N/A',
                  this.getWinetypeName(item.wineTypeID) || 'N/A',
                  'R ' + item.winePrice || 'N/A',
                  wineActive
                ];
              })
              ]
            }
          }
        ],
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10]
          },
          subheader: {
            fontSize: 12,
            italics: true,
            margin: [0, 5, 0, 5]
          }
        }
      };
    } else {
      documentDefinition = {
        content: [
          { text: 'Wine Report', style: 'header' },
          {
            table: {
              headerRows: 1,
              widths: ['auto'],
              body: [['No wine items found.']],
            },
          },
        ],
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10],
          },
        },
      };
    }

    const pdfDocGenerator = pdfMake.createPdf(documentDefinition);

    pdfDocGenerator.getBlob((pdfBlob: Blob) => {
      resolve(pdfBlob);
    });
  });
}
}

async generateWinesReportpdf(winesData: Wine[], currentDate: string): Promise<Blob> {
  this.loadWines();

  const delay = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

  await delay(50);
  return new Promise<Blob>((resolve, reject) => {
    let documentDefinition: any;

    if (winesData.length > 0) {
      console.log(winesData)
      documentDefinition = {
        content: [
          { text: 'Wines Report', style: 'header' },
          { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
          { text: `Date: ${currentDate}`, style: 'subheader' },
          '\n',
          {
            table: {
              headerRows: 1,
              widths: ['auto', '*', 'auto', 'auto', 'auto', 'auto'],
              body: [
                ['No.', 'Wine Name', 'Varietal', 'Type', 'Price', 'Active'],
                ...winesData.map((item, index) => {

                  const wineActive = item.displayWine ? "Yes" : "No"; 

                  return [
                  index + 1,
                  item.name|| 'N/A',
                  this.getVarietalName(item.varietalID) || 'N/A',
                  this.getWinetypeName(item.wineTypeID) || 'N/A',
                  'R ' + item.winePrice || 'N/A',
                  wineActive
                ];
              })
              ]
            }
          }
        ],
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10]
          },
          subheader: {
            fontSize: 12,
            italics: true,
            margin: [0, 5, 0, 5]
          }
        }
      };
    } else {
      documentDefinition = {
        content: [
          { text: 'Wine Report', style: 'header' },
          {
            table: {
              headerRows: 1,
              widths: ['auto'],
              body: [['No wine items found.']],
            },
          },
        ],
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10],
          },
        },
      };
    }

    pdfMake.createPdf(documentDefinition).download(`wines_report.pdf`);
  });
}




}