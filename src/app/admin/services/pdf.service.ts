import { Injectable } from '@angular/core';
import pdfMake from 'pdfmake/build/pdfmake';
import pdfFonts from 'pdfmake/build/vfs_fonts';
import { Inventory } from 'src/app/Model/inventory';
import { DataServiceService } from 'src/app/customer/services/data-service.service';
import { Event } from 'src/app/Model/event';
import { SupplierOrder } from 'src/app/Model/supplierOrder';
import { Blacklist } from 'src/app/Model/blacklist';
import { Wine } from 'src/app/Model/wine';
import { WineType } from 'src/app/Model/winetype';
import { Varietal } from 'src/app/Model/varietal';
import { ToastrService } from 'ngx-toastr';
import { WineService } from '../services/wine.service';
import { WinetypeService } from './winetype.service';
import { VarietalService } from './varietal.service';
import { SupplierService } from './supplier.service';
import { style } from '@angular/animations';


pdfMake.vfs = pdfFonts.pdfMake.vfs;

@Injectable({
  providedIn: 'root'
})
export class PdfService {
  user: any;
  blacklistData: any;

  constructor(private userService: DataServiceService,
    private wineService: WineService,
    private winetypeService: WinetypeService,
    private varietalService: VarietalService,
    private supplierService: SupplierService,
    private toastr: ToastrService) {
    var tokenUser = this.userService.getUserFromToken();
    this.userService.getUser(tokenUser!.email).subscribe((result: any) => {
      this.user = result.user;
    })
  }
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  //Inventory Report 
  wines: Wine[] = [];
  allWines: Wine[] = [];
  winetypes: WineType[] = [];
  varietals: Varietal[] = [];
  searchQuery: string = '';

  getWineName(wineID: number): string {
    console.log('Name ID', wineID)
    let wine = this.wines.find(x => x.wineID == wineID);
    console.log('Wine', wine)
    return wine ? wine.name : 'Unknown';
  }

  getVarietalName(varietalID: number): string {
    console.log('V ID', varietalID)
    let varietal = this.varietals.find(x => x.varietalID == varietalID);
    return varietal?.name || 'Unknown';
  }

  getWinetypeName(wineTypeID?: number): string {
    console.log('Type ID', wineTypeID)
    let winetype = this.winetypes.find(x => x.wineTypeID == wineTypeID);
    return winetype?.name || 'Unknown';
  }

  async loadWines(): Promise<void> {
    try {
      this.allWines = await this.wineService.getWines();
      console.log('All Wines:', this.allWines);
      this.winetypes = await this.winetypeService.getWinetypes();
      this.varietals = await this.varietalService.getVarietals();
      this.filterWines();
    } catch (error) {
      console.error(error);
      this.toastr.error('Error, please try again', 'Wine Table');
    }
  }

  filterWines(): void {
    if (this.searchQuery.trim() !== '') {
      const query = this.searchQuery.toLowerCase().trim();
      this.wines = this.allWines.filter(wine =>
        wine.name.toLowerCase().includes(query) ||
        wine.vintage.toString().includes(query) ||
        wine.varietalID.toString().includes(query) ||
        wine.wineTypeID.toString().includes(query) ||
        wine.winePrice.toString().includes(query)
      );
    } else {
      this.wines = [...this.allWines]; // if searchQuery is empty, show all wines
    }
  }


  generateInventoryPdf(inventoryData: Inventory[], currentDate: string): void {
    this.loadWines();
    let documentDefinition: any;
    if (inventoryData.length > 0) {
      console.log(inventoryData)
      documentDefinition = {
        content: [
          { text: 'Inventory Report', style: 'header' },
          { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
          { text: `Date: ${currentDate}`, style: 'subheader' },
          '\n',
          {
            table: {
              headerRows: 1,
              widths: ['auto', '*', 'auto', 'auto', 'auto', 'auto', 'auto'],
              body: [
                ['No.', 'Name', 'Varietal', 'Type', 'Price', 'Stock Limit', 'Quantity on Hand'],
                ...inventoryData.map((item, index) => [
                  index + 1,
                  this.getWineName(item.wineID) || 'N/A',
                  this.getVarietalName(item.varietalID) || 'N/A',
                  this.getWinetypeName(item.wineTypeID) || 'N/A',
                  'R ' + item.winePrice || 'N/A',
                  item.stockLimit || 'N/A',
                  item.quantityOnHand || 'N/A'
                ])
              ]
            }
          }
        ],
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10]
          },
          subheader: {
            fontSize: 12,
            italics: true,
            margin: [0, 5, 0, 5]
          }
        }
      };
    } else {
      documentDefinition = {
        content: [
          { text: 'Inventory Report', style: 'header' },
          { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
          { text: `Date: ${currentDate}`, style: 'subheader' },
          '\n',
          {
            table: {
              headerRows: 1,
              widths: ['auto'],
              body: [
                ["There is nothing stored in Inventory at the moment."]
              ]
            }
          }
        ],
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10]
          },
          subheader: {
            fontSize: 12,
            italics: true,
            margin: [0, 5, 0, 5]
          }
        }
      };
    }

    pdfMake.createPdf(documentDefinition).download('inventory_report.pdf');
  }

  generateInventoryReport(inventoryData: Inventory[], currentDate: string): Promise<Blob> {
    this.loadWines();
    return new Promise<Blob>((resolve, reject) => {
      let documentDefinition: any;
  
      if (inventoryData.length > 0) {
        console.log(inventoryData)
        documentDefinition = {
          content: [
            { text: 'Inventory Report', style: 'header' },
            { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
            { text: `Date: ${currentDate}`, style: 'subheader' },
            '\n',
            {
              table: {
                headerRows: 1,
                widths: ['auto', '*', 'auto', 'auto', 'auto', 'auto', 'auto'],
                body: [
                  ['No.', 'Name', 'Varietal', 'Type', 'Price', 'Stock Limit', 'Quantity on Hand'],
                  ...inventoryData.map((item, index) => [
                    index + 1,
                    this.getWineName(item.wineID) || 'N/A',
                    this.getVarietalName(item.varietalID) || 'N/A',
                    this.getWinetypeName(item.wineTypeID) || 'N/A',
                    'R ' + item.winePrice || 'N/A',
                    item.stockLimit || 'N/A',
                    item.quantityOnHand || 'N/A'
                  ])
                ]
              }
            }
          ],
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10]
            },
            subheader: {
              fontSize: 12,
              italics: true,
              margin: [0, 5, 0, 5]
            }
          }
        };
      } else {
        documentDefinition = {
          content: [
            { text: 'Inventory Report', style: 'header' },
            {
              table: {
                headerRows: 1,
                widths: ['auto'],
                body: [['No inventory items found.']],
              },
            },
          ],
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10],
            },
          },
        };
      }
  
      const pdfDocGenerator = pdfMake.createPdf(documentDefinition);
  
      pdfDocGenerator.getBlob((pdfBlob: Blob) => {
        resolve(pdfBlob);
      });
    });
  }
  



  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  // generateRefundsPdf(refundData: RefundRequest[], beginDate: Date, endDate: Date): void {
  //   let beginDate2 = new Date(beginDate);
  //   let endDate2 = new Date(endDate);

  //   let formattedBeginDate = `${beginDate2.getDate()}-${beginDate2.getMonth() + 1}-${beginDate2.getFullYear()}`;
  //   let formattedEndDate = `${endDate2.getDate()}-${endDate2.getMonth() + 1}-${endDate2.getFullYear()}`;

  //   let documentDefinition: any;

  //   if (refundData.length > 0) {
  //     documentDefinition = {
  //       content: [
  //         { text: 'Refunds Report', style: 'header' },
  //         { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
  //         { text: `From: ${formattedBeginDate} To: ${formattedEndDate}`, style: 'subheader' },
  //         {
  //           table: {
  //             headerRows: 1,
  //             widths: ['auto', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto'],
  //             body: [
  //               ['No.', 'WineId', 'OrderId', 'Reference Number', 'Requested On', 'Description', 'Email', 'Status'],
  //               ...refundData.map((item, index) => {
  //                 let status = 'Pending'; // Status for each row
  //                 if (item.status == 0) {
  //                   status = "In Progress";
  //                 } else if (item.status == 1) {
  //                   status = "Approved";
  //                 } else if (item.status == 2) {
  //                   status = "Not Approved";
  //                 }

  //                 return [index, item.wineId, item.orderId, item.orderRefNum, item.requestedOn, item.description, item.email, status];
  //               })
  //             ]
  //           }
  //         }
  //       ],
  //       styles: {
  //         header: {
  //           fontSize: 16,
  //           bold: true,
  //           margin: [0, 10]
  //         },
  //         subheader: {
  //           fontSize: 12,
  //           margin: [0, 6]
  //         }
  //       },
  //       pageOrientation: 'landscape'
  //     };
  //   } else {
  //     documentDefinition = {
  //       content: [
  //         { text: 'Refunds Report', style: 'header' },
  //         { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
  //         { text: `From: ${formattedBeginDate} To: ${formattedEndDate}`, style: 'subheader' },
  //         {
  //           table: {
  //             headerRows: 1,
  //             widths: ['auto'],
  //             body: [
  //               ["There were no refunds between the selected dates."]
  //             ]
  //           }
  //         }
  //       ],
  //       styles: {
  //         header: {
  //           fontSize: 16,
  //           bold: true,
  //           margin: [0, 10]
  //         },
  //         subheader: {
  //           fontSize: 12,
  //           margin: [0, 6]
  //         }
  //       },
  //       pageOrientation: 'landscape'
  //     };
  //   }

  //   pdfMake.createPdf(documentDefinition).download(`refunds_report_${formattedBeginDate}_${formattedEndDate}.pdf`);
  // }


  // generateRefundReport(refundData: RefundRequest[], currentDate: string): Promise<Blob> {
  //   return new Promise<Blob>((resolve, reject) => {
  //     let documentDefinition: any;
  
  //     if (refundData.length > 0) {
  //       documentDefinition = {
  //         content: [
  //           { text: 'Refunds Report', style: 'header' },
  //           { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
  //           { text: `From: ${formattedBeginDate} To: ${formattedEndDate}`, style: 'subheader' },
  //           {
  //             table: {
  //               headerRows: 1,
  //               widths: ['auto', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto'],
  //               body: [
  //                 ['No.', 'WineId', 'OrderId', 'Reference Number', 'Requested On', 'Description', 'Email', 'Status'],
  //                 ...refundData.map((item, index) => {
  //                   let status = 'Pending'; // Status for each row
  //                   if (item.status == 0) {
  //                     status = "In Progress";
  //                   } else if (item.status == 1) {
  //                     status = "Approved";
  //                   } else if (item.status == 2) {
  //                     status = "Not Approved";
  //                   }
  
  //                   return [index, item.wineId, item.orderId, item.orderRefNum, item.requestedOn, item.description, item.email, status];
  //                 })
  //               ]
  //             }
  //           }
  //         ],
  //         styles: {
  //           header: {
  //             fontSize: 16,
  //             bold: true,
  //             margin: [0, 10]
  //           },
  //           subheader: {
  //             fontSize: 12,
  //             margin: [0, 6]
  //           }
  //         },
  //         pageOrientation: 'landscape'
  //       };
  //     } else {
  //       documentDefinition = {
  //         content: [
  //           { text: 'Refund Report', style: 'header' },
  //           {
  //             table: {
  //               headerRows: 1,
  //               widths: ['auto'],
  //               body: [['No refunds available.']],
  //             },
  //           },
  //         ],
  //         styles: {
  //           header: {
  //             fontSize: 16,
  //             bold: true,
  //             margin: [0, 10, 0, 10],
  //           },
  //         },
  //       };
  //     }
  
  //     const pdfDocGenerator = pdfMake.createPdf(documentDefinition);
  
  //     pdfDocGenerator.getBlob((pdfBlob: Blob) => {
  //       resolve(pdfBlob);
  //     });
  //   });
  // }



  //---------------------------------------------------  Events  ----------------------------------------------------------------



  generateEventsPdf(eventData: Event[], beginDate: Date, endDate: Date): void {
    let formattedBeginDate = new Date(beginDate).toLocaleDateString();
    let formattedEndDate = new Date(endDate).toLocaleDateString();
    let generatedDate = Date.now();

    let documentDefinition: any;

    if (eventData.length > 0) {
      documentDefinition = {
        content: [
          { text: 'Events Report', style: 'header' },
          { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
          { text: `Generated On: ${new Date(generatedDate).toLocaleDateString()}`, style: 'subheader' },
          { text: `Time Period: ${formattedBeginDate} -- ${formattedEndDate}`, style: 'subheader' },
          '\n',
          {
            table: {
                headerRows: 1,
                widths: ['auto', '*', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto'], 
                body: [
                    ['No.', 'Name', 'Date', 'Tickets Available', 'Tickets Sold', 'Price', 'Early Bird Discount', 'Revenue', 'Active'],
                    ...eventData.map((event, index) => {
        
                        const eventEarlyBirdlimit = event.earlyBird?.limit || 0;  // Default to 0 if null
                        const eventEarlyBirdPercentage = event.earlyBird?.percentage || 0;  // Default to 0 if null
                        const eventActive = event.displayEvent ? "Yes" : "No"; 
        
                        const earlyBirdPrice = event.eventPrice - (event.eventPrice * eventEarlyBirdPercentage / 100);
                        const earlyBirdDiscountAmount = event.eventPrice - earlyBirdPrice;  // Calculating discount amount
        
                        const earlyBirdTicketsSold = event.tickets_Sold <= eventEarlyBirdlimit ? event.tickets_Sold : eventEarlyBirdlimit;
                        const regularTicketsSold = event.tickets_Sold - earlyBirdTicketsSold;
        
                        const revenueFromEarlyBirdTickets = earlyBirdTicketsSold * earlyBirdPrice;
                        const revenueFromRegularTickets = regularTicketsSold * event.eventPrice;
                        const totalRevenue = revenueFromEarlyBirdTickets + revenueFromRegularTickets;
        
                        return [
                            index + 1,
                            event.eventName,
                            new Date(event.eventDate).toLocaleDateString(),
                            event.tickets_Available,
                            event.tickets_Sold,
                            `R${event.eventPrice}`,
                            `R${earlyBirdDiscountAmount.toFixed(2)}`,  // Added "Early Bird Discount" column value and fixed it to two decimal places
                            `R${totalRevenue.toFixed(2)}`, // Fixing to two decimal places for cleaner display
                            eventActive
                        ];
                    })
                ]
            }
        }
        

        ],
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10]
          },
          subheader: {
            fontSize: 12,
            italics: true,
            margin: [0, 5, 0, 5]
          }
        }
      };
    } else {
      documentDefinition = {
        content: [
          { text: 'Events Report', style: 'header' },
          { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
          { text: `From: ${formattedBeginDate} To: ${formattedEndDate}`, style: 'subheader' },
          '\n',
          {
            table: {
              headerRows: 1,
              widths: ['auto'],
              body: [
                ["There are no events between the specified dates."]
              ]
            }
          }
        ],
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10]
          },
          subheader: {
            fontSize: 12,
            italics: true,
            margin: [0, 5, 0, 5]
          }
        }
      };
    }

    pdfMake.createPdf(documentDefinition).download(`events_report_${formattedBeginDate}_${formattedEndDate}.pdf`);
  }

  generateEventsReport(eventData: Event[], beginDate: Date, endDate: Date, currentDate: string): Promise<Blob> {
    return new Promise<Blob>((resolve, reject) => {
      let documentDefinition: any;
      let formattedBeginDate = new Date(beginDate).toLocaleDateString();
      let formattedEndDate = new Date(endDate).toLocaleDateString();
      let generatedDate = Date.now();
  
      if (eventData.length > 0) {
        documentDefinition = {
          content: [
            { text: 'Events Report', style: 'header' },
            { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
            { text: `Generated On: ${new Date(generatedDate).toLocaleDateString()}`, style: 'subheader' },
            { text: `Time Period: ${formattedBeginDate} -- ${formattedEndDate}`, style: 'subheader' },
            '\n',
            {
              table: {
                  headerRows: 1,
                  widths: ['auto', '*', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto'], 
                  body: [
                      ['No.', 'Name', 'Date', 'Tickets Available', 'Tickets Sold', 'Price', 'Early Bird Discount', 'Revenue', 'Active'],
                      ...eventData.map((event, index) => {
          
                          const eventEarlyBirdlimit = event.earlyBird?.limit || 0;  // Default to 0 if null
                          const eventEarlyBirdPercentage = event.earlyBird?.percentage || 0;  // Default to 0 if null
                          const eventActive = event.displayEvent ? "Yes" : "No"; 
          
                          const earlyBirdPrice = event.eventPrice - (event.eventPrice * eventEarlyBirdPercentage / 100);
                          const earlyBirdDiscountAmount = event.eventPrice - earlyBirdPrice;  // Calculating discount amount
          
                          const earlyBirdTicketsSold = event.tickets_Sold <= eventEarlyBirdlimit ? event.tickets_Sold : eventEarlyBirdlimit;
                          const regularTicketsSold = event.tickets_Sold - earlyBirdTicketsSold;
          
                          const revenueFromEarlyBirdTickets = earlyBirdTicketsSold * earlyBirdPrice;
                          const revenueFromRegularTickets = regularTicketsSold * event.eventPrice;
                          const totalRevenue = revenueFromEarlyBirdTickets + revenueFromRegularTickets;
          
                          return [
                              index + 1,
                              event.eventName,
                              new Date(event.eventDate).toLocaleDateString(),
                              event.tickets_Available,
                              event.tickets_Sold,
                              `R${event.eventPrice}`,
                              `R${earlyBirdDiscountAmount.toFixed(2)}`,  // Added "Early Bird Discount" column value and fixed it to two decimal places
                              `R${totalRevenue.toFixed(2)}`, // Fixing to two decimal places for cleaner display
                              eventActive
                          ];
                      })
                  ]
              }
          }
          
  
          ],
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10]
            },
            subheader: {
              fontSize: 12,
              italics: true,
              margin: [0, 5, 0, 5]
            }
          }
        };
      } else {
        documentDefinition = {
          content: [
            { text: 'Events Report', style: 'header' },
            {
              table: {
                headerRows: 1,
                widths: ['auto'],
                body: [['No events available.']],
              },
            },
          ],
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10],
            },
          },
        };
      }
  
      const pdfDocGenerator = pdfMake.createPdf(documentDefinition);
  
      pdfDocGenerator.getBlob((pdfBlob: Blob) => {
        resolve(pdfBlob);
      });
    });
  }
  
  


  //---------------------------------------------------  Events  ----------------------------------------------------------------
  async generateSupplierOrdersPdf(supplierOrderData: SupplierOrder[]): Promise<void> {
    console.log(supplierOrderData);
    let generatedDate = Date.now();

    let body: any[] = [
        ['#', 'Supplier Name', 'Wine Name', 'Quantity Ordered', 'Order Cost', 'VAT (15%)', 'Sub-Total']
    ];

    let grandTotal = 0;

    // Step 1: Fetch supplier names
    const supplierNames = await Promise.all(
        supplierOrderData.map(order => {
            return new Promise<string>((resolve, reject) => {
                this.supplierService.getSupplier(order.supplierID!).subscribe(
                    (result: any) => resolve(result.name),
                    error => reject(error)
                );
            });
        })
    );

    // Step 2: Process the orders
    supplierOrderData.forEach((order, index) => {
        const vat = (order.orderTotal ?? 0) * 0.15;
        const totalWithVat = (order.orderTotal ?? 0) + vat;
        grandTotal += totalWithVat;

        const quantityOrdered = order.quantity_Ordered ?? 0;

        body.push([
            index + 1,
            supplierNames[index],
            order.wineName,
            quantityOrdered,
            "R " + (order.orderTotal ?? 0).toFixed(2),
            `R ${vat.toFixed(2)}`,
            `R ${totalWithVat.toFixed(2)}`
        ]);
    });

    body.push(
        [{}, {}, {}, {}, {}, { text: 'Grand Total:', bold: true }, { text: `R ${grandTotal.toFixed(2)}`, bold: true }]
    );

    type Alignment = 'left' | 'right' | 'center' | 'justify';

    const documentDefinition = {
        content: [
            { text: 'Supplier Order Report', style: 'header' },
            { text: `Generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
            { text: `Generated On: ${new Date(generatedDate).toLocaleDateString()}`, style: 'subheader' },
            '\n',
            {
                table: {
                    headerRows: 1,
                    widths: ['5%', '13%', '16%', '11%', '18%', '15%', '22%'],
                    body: body
                },
                // Add a layout to style specific rows in the table
                layout: {
                    fillColor: function (rowIndex: number, node: any, columnIndex: number) {
                        return rowIndex === body.length - 1 ? '#DDDDDD' : null;  // grey background for the last row
                    }
                }
            }
        ],
        styles: {
            header: {
                fontSize: 16,
                bold: true,
                margin: [0, 0, 10, 0] as [number, number, number, number]
            },
            subheader: {
                fontSize: 12,
                margin: [0, 0, 6, 0] as [number, number, number, number],
                alignment: 'left' as Alignment
            }
        },
        pageOrientation: 'portrait' as const
    };

    pdfMake.createPdf(documentDefinition).download(`supplier_order_report_${generatedDate}.pdf`);
}

async generateSupplierOrders(supplierOrderData: SupplierOrder[]): Promise<Blob> {
  return new Promise<Blob>((resolve, reject) => {
      console.log(supplierOrderData);
      let generatedDate = Date.now();

      let body: any[] = [
          ['#', 'Supplier Name', 'Wine Name', 'Quantity Ordered', 'Order Cost', 'VAT (15%)', 'Sub-Total']
      ];

      let grandTotal = 0;

      // Step 1: Fetch supplier names
      Promise.all(
          supplierOrderData.map(order => {
              return new Promise<string>((resolve, reject) => {
                  this.supplierService.getSupplier(order.supplierID!).subscribe(
                      (result: any) => resolve(result.name),
                      error => reject(error)
                  );
              });
          })
      ).then(supplierNames => {

          // Step 2: Process the orders
          supplierOrderData.forEach((order, index) => {
              const vat = (order.orderTotal ?? 0) * 0.15;
              const totalWithVat = (order.orderTotal ?? 0) + vat;
              grandTotal += totalWithVat;

              const quantityOrdered = order.quantity_Ordered ?? 0;

              body.push([
                  index + 1,
                  supplierNames[index],
                  order.wineName,
                  quantityOrdered,
                  "R " + (order.orderTotal ?? 0).toFixed(2),
                  `R ${vat.toFixed(2)}`,
                  `R ${totalWithVat.toFixed(2)}`
              ]);
          });

          body.push(
              [{}, {}, {}, {}, {}, { text: 'Grand Total:', bold: true }, { text: `R ${grandTotal.toFixed(2)}`, bold: true }]
          );

          type Alignment = 'left' | 'right' | 'center' | 'justify';

          const documentDefinition = {
              content: [
                  { text: 'Supplier Order Report', style: 'header' },
                  { text: `Generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
                  { text: `Generated On: ${new Date(generatedDate).toLocaleDateString()}`, style: 'subheader' },
                  '\n',
                  {
                      table: {
                          headerRows: 1,
                          widths: ['5%', '13%', '16%', '11%', '18%', '15%', '22%'],
                          body: body
                      },
                      // Add a layout to style specific rows in the table
                      layout: {
                          fillColor: function (rowIndex: number, node: any, columnIndex: number) {
                              return rowIndex === body.length - 1 ? '#DDDDDD' : null;  // grey background for the last row
                          }
                      }
                  }
              ],
              styles: {
                  header: {
                      fontSize: 16,
                      bold: true,
                      margin: [0, 0, 10, 0] as [number, number, number, number]
                  },
                  subheader: {
                      fontSize: 12,
                      margin: [0, 0, 6, 0] as [number, number, number, number],
                      alignment: 'left' as Alignment
                  }
              },
              pageOrientation: 'portrait' as const
          };

          const pdfDocGenerator = pdfMake.createPdf(documentDefinition);

          pdfDocGenerator.getBlob((pdfBlob: Blob) => {
              resolve(pdfBlob);
          });
      });
  });
}



  

    //---------------------------------------------------  Blacklist  ----------------------------------------------------------------

  generateBlacklistPdf(blacklistData: Blacklist[], currentDate: string): void {
    let documentDefinition: any;

    if (blacklistData.length > 0) {
      documentDefinition = {
        content: [
          { text: 'Blacklist Report', style: 'header' },
          { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
          { text: `Date: ${currentDate}`, style: 'subheader' },

          '\n',
          {
            table: {
              headerRows: 1,
              widths: ['auto', '*', 'auto'],
              body: [
                ['No.', 'Email', 'Reason'],
                ...blacklistData.map((entry, index) => [

                  index + 1,
                  entry.email,
                  entry.reason,
                ]),
              ],
            },
          },
        ],
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10],
          },
        },
      };
    } else {
      documentDefinition = {
        content: [
          { text: 'Blacklist Report', style: 'header' },
          {
            table: {
              headerRows: 1,
              widths: ['auto'],
              body: [['No blacklist entries found.']],
            },
          },
        ],
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10],
          },
        },
      };
    }

    pdfMake.createPdf(documentDefinition).download(`blacklist_report.pdf`);
  }

  generateBlacklist(blacklistData: Blacklist[], currentDate: string): Promise<Blob> {
    return new Promise<Blob>((resolve, reject) => {
      let documentDefinition: any;

      if (blacklistData.length > 0) {
        documentDefinition = {
          content: [
            { text: 'Blacklist Report', style: 'header' },
            { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
            { text: `Date: ${currentDate}`, style: 'subheader' },
            
            '\n',
            {
              table: {
                headerRows: 1,
                widths: ['auto', '*', 'auto'],
                body: [
                  ['No.', 'Email', 'Reason'],
                  ...blacklistData.map((entry, index) => [
                    index + 1,
                    entry.email,
                    entry.reason,
                  ]),
                ],
              },
            },
          ],
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10],
            },
          },
        };
      } else {
        documentDefinition = {
          content: [
            { text: 'Blacklist Report', style: 'header' },
            {
              table: {
                headerRows: 1,
                widths: ['auto'],
                body: [['No blacklist entries found.']],
              },
            },
          ],
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10],
            },
          },
        };
      }

      const pdfDocGenerator = pdfMake.createPdf(documentDefinition);

      pdfDocGenerator.getBlob((pdfBlob: Blob) => {
        resolve(pdfBlob);
      });
    });
  }






generateWinesReport(winesData: Wine[], currentDate: string): Promise<Blob> {
  this.loadWines();
  return new Promise<Blob>((resolve, reject) => {
    let documentDefinition: any;

    if (winesData.length > 0) {
      console.log(winesData)
      documentDefinition = {
        content: [
          { text: 'Wines Report', style: 'header' },
          { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
          { text: `Date: ${currentDate}`, style: 'subheader' },
          '\n',
          {
            table: {
              headerRows: 1,
              widths: ['auto', '*', 'auto', 'auto', 'auto', 'auto'],
              body: [
                ['No.', 'Wine Name', 'Varietal', 'Type', 'Price', 'Active'],
                ...winesData.map((item, index) => {

                  const wineActive = item.displayWine ? "Yes" : "No"; 

                  return [
                  index + 1,
                  item.name|| 'N/A',
                  this.getVarietalName(item.varietalID) || 'N/A',
                  this.getWinetypeName(item.wineTypeID) || 'N/A',
                  'R ' + item.winePrice || 'N/A',
                  wineActive
                ];
              })
              ]
            }
          }
        ],
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10]
          },
          subheader: {
            fontSize: 12,
            italics: true,
            margin: [0, 5, 0, 5]
          }
        }
      };
    } else {
      documentDefinition = {
        content: [
          { text: 'Wine Report', style: 'header' },
          {
            table: {
              headerRows: 1,
              widths: ['auto'],
              body: [['No wine items found.']],
            },
          },
        ],
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10],
          },
        },
      };
    }

    const pdfDocGenerator = pdfMake.createPdf(documentDefinition);

    pdfDocGenerator.getBlob((pdfBlob: Blob) => {
      resolve(pdfBlob);
    });
  });
}

generateWinesReportpdf(winesData: Wine[], currentDate: string): Promise<Blob> {
  this.loadWines();
  return new Promise<Blob>((resolve, reject) => {
    let documentDefinition: any;

    if (winesData.length > 0) {
      console.log(winesData)
      documentDefinition = {
        content: [
          { text: 'Wines Report', style: 'header' },
          { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
          { text: `Date: ${currentDate}`, style: 'subheader' },
          '\n',
          {
            table: {
              headerRows: 1,
              widths: ['auto', '*', 'auto', 'auto', 'auto', 'auto'],
              body: [
                ['No.', 'Wine Name', 'Varietal', 'Type', 'Price', 'Active'],
                ...winesData.map((item, index) => {

                  const wineActive = item.displayWine ? "Yes" : "No"; 

                  return [
                  index + 1,
                  item.name|| 'N/A',
                  this.getVarietalName(item.varietalID) || 'N/A',
                  this.getWinetypeName(item.wineTypeID) || 'N/A',
                  'R ' + item.winePrice || 'N/A',
                  wineActive
                ];
              })
              ]
            }
          }
        ],
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10]
          },
          subheader: {
            fontSize: 12,
            italics: true,
            margin: [0, 5, 0, 5]
          }
        }
      };
    } else {
      documentDefinition = {
        content: [
          { text: 'Wine Report', style: 'header' },
          {
            table: {
              headerRows: 1,
              widths: ['auto'],
              body: [['No wine items found.']],
            },
          },
        ],
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10],
          },
        },
      };
    }

    pdfMake.createPdf(documentDefinition).download(`wines_report.pdf`);
  });
}




}