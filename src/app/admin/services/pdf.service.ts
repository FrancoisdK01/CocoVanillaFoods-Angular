import { Injectable } from '@angular/core';
import pdfMake from 'pdfmake/build/pdfmake';
import pdfFonts from 'pdfmake/build/vfs_fonts';
import { RefundRequest } from 'src/app/Model/RefundRequest';
import { Inventory } from 'src/app/Model/inventory';
import { DataServiceService } from 'src/app/customer/services/data-service.service';
import { Event } from 'src/app/Model/event';
import { Content } from 'pdfmake/interfaces';
import { SupplierOrder } from 'src/app/Model/supplierOrder';
import { Blacklist } from 'src/app/Model/blacklist';
import { Wine } from 'src/app/Model/wine';
import { WineType } from 'src/app/Model/winetype';
import { Varietal } from 'src/app/Model/varietal';
import { ToastrService } from 'ngx-toastr';
import { WineService } from '../services/wine.service';
import { WinetypeService } from './winetype.service';
import { VarietalService } from './varietal.service';


pdfMake.vfs = pdfFonts.pdfMake.vfs;

@Injectable({
  providedIn: 'root'
})
export class PdfService {
  user: any;
  blacklistData: any;

  constructor(private userService: DataServiceService,
    private wineService: WineService,
    private winetypeService: WinetypeService,
    private varietalService: VarietalService,
    private toastr: ToastrService) {
    var tokenUser = this.userService.getUserFromToken();
    this.userService.getUser(tokenUser!.email).subscribe((result: any) => {
      this.user = result.user;
    })
  }
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  //Inventory Report 
  wines: Wine[] = [];
  allWines: Wine[] = [];
  winetypes: WineType[] = [];
  varietals: Varietal[] = [];
  searchQuery: string = '';


  getWineName(wineID: number): string {
    console.log('Name ID', wineID)
    let wine = this.wines.find(x => x.wineID == wineID);
    console.log('Wine', wine)
    return wine ? wine.name : 'Unknown';
  }

  getVarietalName(varietalID: number): string {
    console.log('V ID', varietalID)
    let varietal = this.varietals.find(x => x.varietalID == varietalID);
    return varietal?.name || 'Unknown';
  }

  getWinetypeName(wineTypeID?: number): string {
    console.log('Type ID', wineTypeID)
    let winetype = this.winetypes.find(x => x.wineTypeID == wineTypeID);
    return winetype?.name || 'Unknown';
  }

  async loadWines(): Promise<void> {
    try {
      this.allWines = await this.wineService.getWines();
      //console.log('All Wines:', this.allWines);
      this.winetypes = await this.winetypeService.getWinetypes();
      this.varietals = await this.varietalService.getVarietals();
      this.filterWines();
    } catch (error) {
      console.error(error);
      this.toastr.error('Error, please try again', 'Wine Table');
    }
  }

  filterWines(): void {
    if (this.searchQuery.trim() !== '') {
      const query = this.searchQuery.toLowerCase().trim();
      this.wines = this.allWines.filter(wine =>
        wine.name.toLowerCase().includes(query) ||
        wine.vintage.toString().includes(query) ||
        wine.varietalID.toString().includes(query) ||
        wine.wineTypeID.toString().includes(query) ||
        wine.winePrice.toString().includes(query)
      );
    } else {
      this.wines = [...this.allWines]; // if searchQuery is empty, show all wines
    }
  }


  generateInventoryPdf(inventoryData: Inventory[], currentDate: string): void {
    this.loadWines();
    let documentDefinition: any;
    if (inventoryData.length > 0) {
      console.log(inventoryData)
      documentDefinition = {
        content: [
          { text: 'Inventory Report', style: 'header' },
          { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
          { text: `Date: ${currentDate}`, style: 'subheader' },
          '\n',
          {
            table: {
              headerRows: 1,
              widths: ['auto', '*', 'auto', 'auto', 'auto', 'auto', 'auto'],
              body: [
                ['No.', 'Name', 'Varietal', 'Type', 'Price', 'Stock Limit', 'Quantity on Hand'],
                ...inventoryData.map((item, index) => [
                  index + 1,
                  this.getWineName(item.wineID) || 'N/A',
                  this.getVarietalName(item.varietalID) || 'N/A',
                  this.getWinetypeName(item.wineTypeID) || 'N/A',
                  'R ' + item.winePrice || 'N/A',
                  item.stockLimit || 'N/A',
                  item.quantityOnHand || 'N/A'
                ])
              ]
            }
          }
        ],
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10]
          },
          subheader: {
            fontSize: 12,
            italics: true,
            margin: [0, 5, 0, 5]
          }
        }
      };
    } else {
      documentDefinition = {
        content: [
          { text: 'Inventory Report', style: 'header' },
          { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
          { text: `Date: ${currentDate}`, style: 'subheader' },
          '\n',
          {
            table: {
              headerRows: 1,
              widths: ['auto'],
              body: [
                ["There is nothing stored in Inventory at the moment."]
              ]
            }
          }
        ],
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10]
          },
          subheader: {
            fontSize: 12,
            italics: true,
            margin: [0, 5, 0, 5]
          }
        }
      };
    }

    pdfMake.createPdf(documentDefinition).download('inventory_report.pdf');
  }

  generateInventoryReport(inventoryData: Inventory[], currentDate: string): Promise<Blob> {
    this.loadWines();
    return new Promise<Blob>((resolve, reject) => {
      let documentDefinition: any;
  
      if (inventoryData.length > 0) {
        console.log(inventoryData)
        documentDefinition = {
          content: [
            { text: 'Inventory Report', style: 'header' },
            { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
            { text: `Date: ${currentDate}`, style: 'subheader' },
            '\n',
            {
              table: {
                headerRows: 1,
                widths: ['auto', '*', 'auto', 'auto', 'auto', 'auto', 'auto'],
                body: [
                  ['No.', 'Name', 'Varietal', 'Type', 'Price', 'Stock Limit', 'Quantity on Hand'],
                  ...inventoryData.map((item, index) => [
                    index + 1,
                    this.getWineName(item.wineID) || 'N/A',
                    this.getVarietalName(item.varietalID) || 'N/A',
                    this.getWinetypeName(item.wineTypeID) || 'N/A',
                    'R ' + item.winePrice || 'N/A',
                    item.stockLimit || 'N/A',
                    item.quantityOnHand || 'N/A'
                  ])
                ]
              }
            }
          ],
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10]
            },
            subheader: {
              fontSize: 12,
              italics: true,
              margin: [0, 5, 0, 5]
            }
          }
        };
      } else {
        documentDefinition = {
          content: [
            { text: 'Inventory Report', style: 'header' },
            {
              table: {
                headerRows: 1,
                widths: ['auto'],
                body: [['No inventory items found.']],
              },
            },
          ],
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10],
            },
          },
        };
      }
  
      const pdfDocGenerator = pdfMake.createPdf(documentDefinition);
  
      pdfDocGenerator.getBlob((pdfBlob: Blob) => {
        resolve(pdfBlob);
      });
    });
  }
  



  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  // generateRefundsPdf(refundData: RefundRequest[], beginDate: Date, endDate: Date): void {
  //   let beginDate2 = new Date(beginDate);
  //   let endDate2 = new Date(endDate);

  //   let formattedBeginDate = `${beginDate2.getDate()}-${beginDate2.getMonth() + 1}-${beginDate2.getFullYear()}`;
  //   let formattedEndDate = `${endDate2.getDate()}-${endDate2.getMonth() + 1}-${endDate2.getFullYear()}`;

  //   let documentDefinition: any;

  //   if (refundData.length > 0) {
  //     documentDefinition = {
  //       content: [
  //         { text: 'Refunds Report', style: 'header' },
  //         { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
  //         { text: `From: ${formattedBeginDate} To: ${formattedEndDate}`, style: 'subheader' },
  //         {
  //           table: {
  //             headerRows: 1,
  //             widths: ['auto', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto'],
  //             body: [
  //               ['No.', 'WineId', 'OrderId', 'Reference Number', 'Requested On', 'Description', 'Email', 'Status'],
  //               ...refundData.map((item, index) => {
  //                 let status = 'Pending'; // Status for each row
  //                 if (item.status == 0) {
  //                   status = "In Progress";
  //                 } else if (item.status == 1) {
  //                   status = "Approved";
  //                 } else if (item.status == 2) {
  //                   status = "Not Approved";
  //                 }

  //                 return [index, item.wineId, item.orderId, item.orderRefNum, item.requestedOn, item.description, item.email, status];
  //               })
  //             ]
  //           }
  //         }
  //       ],
  //       styles: {
  //         header: {
  //           fontSize: 16,
  //           bold: true,
  //           margin: [0, 10]
  //         },
  //         subheader: {
  //           fontSize: 12,
  //           margin: [0, 6]
  //         }
  //       },
  //       pageOrientation: 'landscape'
  //     };
  //   } else {
  //     documentDefinition = {
  //       content: [
  //         { text: 'Refunds Report', style: 'header' },
  //         { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
  //         { text: `From: ${formattedBeginDate} To: ${formattedEndDate}`, style: 'subheader' },
  //         {
  //           table: {
  //             headerRows: 1,
  //             widths: ['auto'],
  //             body: [
  //               ["There were no refunds between the selected dates."]
  //             ]
  //           }
  //         }
  //       ],
  //       styles: {
  //         header: {
  //           fontSize: 16,
  //           bold: true,
  //           margin: [0, 10]
  //         },
  //         subheader: {
  //           fontSize: 12,
  //           margin: [0, 6]
  //         }
  //       },
  //       pageOrientation: 'landscape'
  //     };
  //   }

  //   pdfMake.createPdf(documentDefinition).download(`refunds_report_${formattedBeginDate}_${formattedEndDate}.pdf`);
  // }


  // generateRefundReport(refundData: RefundRequest[], currentDate: string): Promise<Blob> {
  //   return new Promise<Blob>((resolve, reject) => {
  //     let documentDefinition: any;
  
  //     if (refundData.length > 0) {
  //       documentDefinition = {
  //         content: [
  //           { text: 'Refunds Report', style: 'header' },
  //           { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
  //           { text: `From: ${formattedBeginDate} To: ${formattedEndDate}`, style: 'subheader' },
  //           {
  //             table: {
  //               headerRows: 1,
  //               widths: ['auto', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto'],
  //               body: [
  //                 ['No.', 'WineId', 'OrderId', 'Reference Number', 'Requested On', 'Description', 'Email', 'Status'],
  //                 ...refundData.map((item, index) => {
  //                   let status = 'Pending'; // Status for each row
  //                   if (item.status == 0) {
  //                     status = "In Progress";
  //                   } else if (item.status == 1) {
  //                     status = "Approved";
  //                   } else if (item.status == 2) {
  //                     status = "Not Approved";
  //                   }
  
  //                   return [index, item.wineId, item.orderId, item.orderRefNum, item.requestedOn, item.description, item.email, status];
  //                 })
  //               ]
  //             }
  //           }
  //         ],
  //         styles: {
  //           header: {
  //             fontSize: 16,
  //             bold: true,
  //             margin: [0, 10]
  //           },
  //           subheader: {
  //             fontSize: 12,
  //             margin: [0, 6]
  //           }
  //         },
  //         pageOrientation: 'landscape'
  //       };
  //     } else {
  //       documentDefinition = {
  //         content: [
  //           { text: 'Refund Report', style: 'header' },
  //           {
  //             table: {
  //               headerRows: 1,
  //               widths: ['auto'],
  //               body: [['No refunds available.']],
  //             },
  //           },
  //         ],
  //         styles: {
  //           header: {
  //             fontSize: 16,
  //             bold: true,
  //             margin: [0, 10, 0, 10],
  //           },
  //         },
  //       };
  //     }
  
  //     const pdfDocGenerator = pdfMake.createPdf(documentDefinition);
  
  //     pdfDocGenerator.getBlob((pdfBlob: Blob) => {
  //       resolve(pdfBlob);
  //     });
  //   });
  // }






  generateEventsPdf(eventData: Event[], beginDate: Date, endDate: Date): void {
    let formattedBeginDate = new Date(beginDate).toLocaleDateString();
    let formattedEndDate = new Date(endDate).toLocaleDateString();

    let documentDefinition: any;

    if (eventData.length > 0) {
      documentDefinition = {
        content: [
          { text: 'Events Report', style: 'header' },
          { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
          { text: `From: ${formattedBeginDate} To: ${formattedEndDate}`, style: 'subheader' },
          '\n',
          {
            table: {
              headerRows: 1,
              widths: ['auto', '*', 'auto', 'auto', 'auto', 'auto', 'auto', 'auto'], // Added a new column for "Active"
              body: [
                ['No.', 'Event Name', 'Event Date', 'Tickets Available', 'Tickets Sold', 'Price', 'Revenue', 'Active'], // Added "Active" header
                ...eventData.map((event, index) => {

                  const eventEarlyBirdlimit = event.earlyBird?.limit;
                  const eventEarlyBirdPercentage = event.earlyBird?.percentage;
                  const eventActive = event.eventDisplay ? "Yes" : "No"; // Convert eventDisplay to "Yes" or "No"

                  // Calculate early bird ticket price
                  const earlyBirdPrice = event.eventPrice - (event.eventPrice * eventEarlyBirdPercentage! / 100);

                  // Determine number of early bird tickets and regular tickets sold
                  const earlyBirdTicketsSold = event.tickets_Sold <= eventEarlyBirdlimit! ? event.tickets_Sold : eventEarlyBirdlimit;
                  const regularTicketsSold = event.tickets_Sold - earlyBirdTicketsSold!;

                  // Calculate revenue
                  const revenueFromEarlyBirdTickets = earlyBirdTicketsSold! * earlyBirdPrice;
                  const revenueFromRegularTickets = regularTicketsSold * event.eventPrice;

                  const totalRevenue = revenueFromEarlyBirdTickets + revenueFromRegularTickets;

                  return [
                    index + 1,
                    event.eventName,
                    new Date(event.eventDate).toLocaleDateString(),
                    event.tickets_Available,
                    event.tickets_Sold,
                    `R${event.eventPrice}`,
                    `R${totalRevenue}`,
                    eventActive  // Added "Active" column value
                  ];
                })
              ]
            }
          }

        ],
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10]
          },
          subheader: {
            fontSize: 12,
            italics: true,
            margin: [0, 5, 0, 5]
          }
        }
      };
    } else {
      documentDefinition = {
        content: [
          { text: 'Events Report', style: 'header' },
          { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
          { text: `From: ${formattedBeginDate} To: ${formattedEndDate}`, style: 'subheader' },
          '\n',
          {
            table: {
              headerRows: 1,
              widths: ['auto'],
              body: [
                ["There are no events between the specified dates."]
              ]
            }
          }
        ],
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10]
          },
          subheader: {
            fontSize: 12,
            italics: true,
            margin: [0, 5, 0, 5]
          }
        }
      };
    }

    pdfMake.createPdf(documentDefinition).download(`events_report_${formattedBeginDate}_${formattedEndDate}.pdf`);
  }

  generateEventsReport(eventData: Event[], currentDate: string): Promise<Blob> {
    return new Promise<Blob>((resolve, reject) => {
      let documentDefinition: any;
  
      if (eventData.length > 0) {
        documentDefinition = {
          content: [
            { text: 'Events Report', style: 'header' },
            { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
            { text: `Date: ${currentDate}`, style: 'subheader' },
            '\n',
            {
              table: {
                headerRows: 1,
                widths: ['auto', '*', 'auto', 'auto', 'auto'],
                body: [
                  ['No.', 'Event Name', 'Event Date', 'Tickets Available', 'Tickets Sold'],
                  ...eventData.map((event, index) => [
                    index + 1,
                    event.eventName,
                    new Date(event.eventDate).toLocaleDateString(),
                    event.tickets_Available,
                    event.tickets_Sold,
                  ]),
                ],
              },
            },
          ],
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10],
            },
          },
        };
      } else {
        documentDefinition = {
          content: [
            { text: 'Events Report', style: 'header' },
            {
              table: {
                headerRows: 1,
                widths: ['auto'],
                body: [['No events available.']],
              },
            },
          ],
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10],
            },
          },
        };
      }
  
      const pdfDocGenerator = pdfMake.createPdf(documentDefinition);
  
      pdfDocGenerator.getBlob((pdfBlob: Blob) => {
        resolve(pdfBlob);
      });
    });
  }
  
  


  //---------------------------------------------------  Events  ----------------------------------------------------------------
  generateSupplierOrdersPdf(supplierOrderData: SupplierOrder[]): void {
    console.log(supplierOrderData);

    let generatedDate = Date.now();

    let content: any[] = [
      { text: 'Supplier Order Report', style: 'header' },
      { text: `Generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
      { text: `Generated On: ${new Date(generatedDate).toLocaleDateString()}`, style: 'subheader' },
      { text: '', style: 'spaceStyle' },
      { text: '', style: 'spaceStyle' }
    ];

    supplierOrderData.forEach((order, index) => {
      let status = "Pending";
      let statusStyle = 'statusPending'; // default style

      if (order.received) {
        status = "Received";
        statusStyle = 'statusReceived';
      } else if (order.paid) {
        status = "Paid";
        statusStyle = 'statusPaid';
      } else if (order.ordered) {
        status = "Ordered";
        statusStyle = 'statusOrdered';
      }

      const vat = (order.orderTotal ?? 0) * 0.15;
      const totalWithVat = (order.orderTotal ?? 0) + vat;

      content.push(
        { text: `Supplier Order # ${index + 1}`, style: 'orderTitle' },
        { text: `Order Date: ${order.dateOrdered}`, style: 'orderDetail' },
        { text: `Status: ${status}`, style: ['orderDetail', statusStyle] },
        {
          table: {
            headerRows: 1,
            widths: ['10%', '20%', '30%', '20%', '20%'],
            body: [
              ['#', 'SupplierID', 'WineName', 'Quantity Ordered', 'Sub-total'],
              [index + 1, order.supplierID, order.wineName, order.quantity_Ordered, "R " + (order.orderTotal ?? 0).toFixed(2)],
              [{}, {}, {}, 'VAT (15%)', `R ${vat.toFixed(2)}`],
              [{}, {}, {}, 'TOTAL', `R ${totalWithVat.toFixed(2)}`]
            ]
          }
        },
        { text: '*********** Order finished ***********', style: 'orderSeparator' },
        { text: '', style: 'spaceStyle' }
      );
    });

    content.push({ text: '*********** Report End ***********', style: 'reportEnd' });

    type Alignment = 'left' | 'right' | 'center' | 'justify';

    const documentDefinition = {
      content: content,
      styles: {
        header: {
          fontSize: 16,
          bold: true,
          margin: [0, 0, 10, 0] as [number, number, number, number] // top, right, bottom, left
        },
        subheader: {
          fontSize: 12,
          margin: [0, 0, 6, 0] as [number, number, number, number],
          alignment: 'left' as Alignment
        },
        orderTitle: {
          fontSize: 14,
          bold: true,
          margin: [0, 0, 10, 0] as [number, number, number, number]
        },
        orderDetail: {
          fontSize: 12,
          margin: [0, 0, 6, 0] as [number, number, number, number]
        },
        orderSeparator: {
          margin: [0, 0, 10, 0] as [number, number, number, number],
          alignment: 'center' as Alignment
        },
        reportEnd: {
          margin: [0, 0, 10, 0] as [number, number, number, number],
          alignment: 'center' as Alignment,
          bold: true
        },
        spaceStyle: {
          margin: [0, 20, 0, 0] as [number, number, number, number]
        },
        statusPending: {
          background: 'lightgray'
        },
        statusOrdered: {
          background: 'red',
          color: 'white' // changing the text color to white for better visibility against the red background
        },
        statusPaid: {
          background: 'blue',
          color: 'white'
        },
        statusReceived: {
          background: 'green',
          color: 'white'
        }
      },

      pageOrientation: 'portrait' as const
    };

    pdfMake.createPdf(documentDefinition).download(`supplier_order_report_${generatedDate}.pdf`);
  }


  

    //---------------------------------------------------  Blacklist  ----------------------------------------------------------------

  generateBlacklistPdf(blacklistData: Blacklist[], currentDate: string): void {
    let documentDefinition: any;

    if (blacklistData.length > 0) {
      documentDefinition = {
        content: [
          { text: 'Blacklist Report', style: 'header' },
          { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
          { text: `Date: ${currentDate}`, style: 'subheader' },

          '\n',
          {
            table: {
              headerRows: 1,
              widths: ['auto', '*', 'auto'],
              body: [
                ['No.', 'Email', 'Reason'],
                ...blacklistData.map((entry, index) => [

                  index + 1,
                  entry.email,
                  entry.reason,
                ]),
              ],
            },
          },
        ],
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10],
          },
        },
      };
    } else {
      documentDefinition = {
        content: [
          { text: 'Blacklist Report', style: 'header' },
          {
            table: {
              headerRows: 1,
              widths: ['auto'],
              body: [['No blacklist entries found.']],
            },
          },
        ],
        styles: {
          header: {
            fontSize: 16,
            bold: true,
            margin: [0, 10, 0, 10],
          },
        },
      };
    }

    pdfMake.createPdf(documentDefinition).download(`blacklist_report.pdf`);
  }

  generateBlacklist(blacklistData: Blacklist[], currentDate: string): Promise<Blob> {
    return new Promise<Blob>((resolve, reject) => {
      let documentDefinition: any;

      if (blacklistData.length > 0) {
        documentDefinition = {
          content: [
            { text: 'Blacklist Report', style: 'header' },
            { text: `Report generated by: ${this.user.first_Name} ${this.user.last_Name}`, style: 'subheader' },
            { text: `Date: ${currentDate}`, style: 'subheader' },
            
            '\n',
            {
              table: {
                headerRows: 1,
                widths: ['auto', '*', 'auto'],
                body: [
                  ['No.', 'Email', 'Reason'],
                  ...blacklistData.map((entry, index) => [
                    index + 1,
                    entry.email,
                    entry.reason,
                  ]),
                ],
              },
            },
          ],
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10],
            },
          },
        };
      } else {
        documentDefinition = {
          content: [
            { text: 'Blacklist Report', style: 'header' },
            {
              table: {
                headerRows: 1,
                widths: ['auto'],
                body: [['No blacklist entries found.']],
              },
            },
          ],
          styles: {
            header: {
              fontSize: 16,
              bold: true,
              margin: [0, 10, 0, 10],
            },
          },
        };
      }

      const pdfDocGenerator = pdfMake.createPdf(documentDefinition);

      pdfDocGenerator.getBlob((pdfBlob: Blob) => {
        resolve(pdfBlob);
      });
    });
  }
}
